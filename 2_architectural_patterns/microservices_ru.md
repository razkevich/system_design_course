# От монолитных систем к микросервисам: эволюция архитектуры

Переход Amazon Prime Video к монолитной архитектуре для своих служб мониторинга и аналитики видео с целью сокращения задержек и операционной сложности продемонстрировал важный архитектурный принцип. Это решение Amazon — одного из первых сторонников микросервисов, чья философия «команды из двух пицц» и сервис-ориентированная архитектура помогли определить этот паттерн — было значимым. Когда Segment и Istio провели аналогичное упрощение архитектуры путем слияния сервисов, сформировалась новая модель.

Это свидетельствует о том, что отрасль поняла: архитектурные решения должны основываться на реальных потребностях, а не на тенденциях. После десяти лет внедрения понимание вышло за рамки цикла ажиотажа и теперь можно определить, когда микросервисы имеют смысл, а когда нет, и какие существуют альтернативы.

Переход от монолитных систем к микросервисам обещал независимое развертывание, лучшую масштабируемость и автономность команд. Для многих организаций эти обещания оправдались. Для других это привело к созданию распределенных монолитных систем, обладающих всей сложностью микросервисов, но не имеющих никаких преимуществ. Успешные команды создают адаптивные архитектуры, которые могут эволюционировать между этими моделями по мере изменения потребностей.

В этом документе рассматривается весь путь микросервисов: их основные принципы и преимущества, модели коммуникации, которые обеспечивают их работу, стратегии декомпозиции монолитных систем, технологический стек, который их поддерживает, подходы к тестированию распределенных систем и современные архитектурные модели, появившиеся на основе реального опыта.

## Анатомия микросервисов

По сути, микросервис — это небольшой автономный сервис, который хорошо выполняет одну задачу. Но что делает сервис по-настоящему «микро»? Дело не в количестве строк кода — размер определяется сложностью и ответственностью, а не количеством строк. Ключевые характеристики, определяющие хорошо спроектированный микросервис, включают:

**Ориентация на бизнес-возможности**: каждый сервис должен соответствовать конкретной бизнес-возможности или области. Сервис аутентификации пользователей обрабатывает аутентификацию, сервис платежей обрабатывает платежи, а сервис инвентаризации управляет уровнями запасов. Это не просто техническая организация — это организация бизнеса в коде.

**Право собственности на данные**: Пожалуй, самым важным принципом является то, что каждый микросервис полностью владеет своими данными. Это означает, что он имеет собственную базу данных, модель данных и является единственным источником достоверной информации для данной области. Никакой другой сервис не должен напрямую обращаться к базе данных другого сервиса — все взаимодействия должны происходить через четко определенные API.
**Независимость от технологии**: Различные сервисы могут использовать разные языки программирования, фреймворки и технологии.

**Независимое развертывание**: команды должны иметь возможность развертывать сервисы независимо, без координации с другими командами. Именно эта автономность обеспечивает быструю итерацию, которую обещают микросервисы.

**Независимость от технологии**: разные сервисы могут использовать разные языки программирования, фреймворки и базы данных. Ваш рекомендательный движок может быть написан на Python с TensorFlow, а платежный сервис — на Java с Spring Boot.

### Важные преимущества

Преимущества микросервисов становятся очевидными при масштабировании. **Независимое масштабирование** позволяет выделять ресурсы там, где они наиболее необходимы — масштабировать сервис обработки видео в часы пиковой нагрузки, сохраняя при этом базовую производительность сервиса профилей пользователей. **Автономность команд** позволяет организациям работать быстрее за счет сокращения затрат на координацию и предоставления командам возможности выбирать собственные технологические стеки и графики развертывания.

**Изоляция неисправностей** означает, что сбой одного сервиса не обязательно приводит к выходу из строя всей системы. Ваш механизм рекомендаций может испытывать трудности, но пользователи по-прежнему могут просматривать, искать и совершать покупки.

### Реальные проблемы

Однако микросервисы вводят сложность, которую многие команды недооценивают. **Сложность распределенных систем** означает необходимость иметь дело с сетевой задержкой, частичными сбоями и конечной согласованностью. **Операционные затраты** увеличиваются — вместо мониторинга одного приложения теперь необходимо отслеживать десятки или сотни сервисов, каждый со своими журналами, метриками и конвейером развертывания.

**Сетевые затраты быстро растут**. То, что кажется простой функцией — воспроизведение видео, загрузка профиля пользователя или обработка платежа — внезапно требует координации нескольких вызовов сервисов. Каждый переход увеличивает задержку, а отладка сбоев превращается в археологические раскопки распределенных систем. Команды часто обнаруживают, что операционная сложность управления десятками независимых сервисов превосходит сложность исходного монолитного решения.

**Распространение сервисов** создает свои собственные проблемы. Придерживаясь философии «делай одно, но делай хорошо», команды часто получают настолько детализированные сервисы, что простые бизнес-операции требуют сложной координации. Когнитивная нагрузка, связанная с отслеживанием зависимостей, пониманием потоков данных и координацией развертывания в разветвленной среде сервисов, может парализовать скорость разработки.

**Согласованность данных** становится проблемой распределенных систем. Когда клиент размещает заказ, вам может потребоваться обновить запасы, обработать платеж и отправить уведомления по нескольким сервисам — и все это при одновременном корректном устранении возможных сбоев.

### Распространенные антипаттерны, которых следует избегать

**Общие базы данных**: как только две службы начинают использовать одну базу данных, вы теряете независимость, которая делает микросервисы ценными. Изменения в схеме базы данных теперь требуют координации между командами, и вы связываете свои службы на уровне данных.

**Распределенные монолиты**: службы, которые настолько тесно связаны, что должны развертываться вместе, полностью противоречат самой идее микросервисов. Если изменение одного сервиса требует изменений в пяти других, у вас распределенный монолит — вся сложность микросервисов без каких-либо преимуществ.

**Преждевременная декомпозиция**: Начало работы с микросервисами с первого дня часто приводит к неправильному определению границ сервисов. Обычно лучше начинать с хорошо структурированного монолита и извлекать сервисы по мере того, как становятся ясными границы доменов и растут команды.


## Коммуникация: нервная система микросервисов

В монолите вызов методов дешевый и надежный. В микросервисах коммуникация становится первостепенной задачей проектирования, от которой зависит надежность и производительность вашей системы. Способ коммуникации сервисов определяет все: от характеристик задержки вашей системы до режимов сбоев.

### Синхронная коммуникация: REST и не только

**HTTP/REST API** остаются наиболее распространенным шаблоном коммуникации. Они просты, широко понятны, и для них доступны отличные инструменты. Когда пользователь запрашивает историю своих заказов, ваш API-шлюз может синхронно вызвать службу заказов, которая затем может вызвать службу пользователя, чтобы дополнить ответ данными о пользователе.

Но REST — не единственный вариант для синхронной коммуникации. **gRPC** приобрел значительную популярность, особенно для внутренней коммуникации между службами. Благодаря Protocol Buffers, обеспечивающим безопасность типов и эффективную сериализацию, gRPC предлагает лучшую производительность и более надежные контракты, чем JSON через HTTP. Такие компании, как Netflix и Uber, построили целые уровни коммуникации микросервисов на gRPC.

**GraphQL** представляет собой интересный компромисс, позволяющий клиентам запрашивать именно те данные, которые им нужны, абстрагируясь от сложности многочисленных вызовов сервисов. Вашему мобильному приложению не нужно знать, поступают ли профили пользователей и история заказов из разных сервисов.

Проблема синхронной коммуникации заключается в **связанности и каскадных сбоях**. Когда сервис A вызывает сервис B, который вызывает сервис C, вы создаете цепочку зависимостей. Если сервис C работает медленно, это влияет на всю цепочку. Если он не работает, вся операция завершается сбоем.

### Асинхронная коммуникация: принятие реальности, в которой в конечном итоге все согласовывается

**Очереди сообщений и потоки событий** развязывают сервисы во времени. Вместо «Обработайте этот платеж и подождите» вы говорите «Запрошен платеж» и продолжаете работу. Это коренным образом меняет характеристики отказоустойчивости вашей системы.

Популярные инструменты, такие как **Apache Kafka**, **RabbitMQ**, и облачные сервисы, такие как **AWS SQS/SNS**, предоставляют инфраструктуру для надежной доставки сообщений. Ключевой вывод заключается в том, что многие бизнес-процессы на самом деле не требуют немедленной согласованности — они требуют конечной согласованности с отличным пользовательским опытом.

Более сложные модели межсервисной коммуникации, включая событийно-ориентированную архитектуру, CQRS и управление распределенными транзакциями с помощью Sagas, см. в нашем специальном [руководстве по событийно-ориентированной архитектуре](./eda.md).
## Декомпозиция: искусство и наука границ сервисов

Пожалуй, ни одно решение в архитектуре микросервисов не является более важным — или более сложным — чем определение границ сервисов. Правильное решение позволит раскрыть весь потенциал независимых команд, работающих с высокой скоростью. Неправильное решение приведет к появлению распределенной «большой грязной кучи», которую будет управлять сложнее, чем монолит, с которого вы начинали.

### Доменно-ориентированное проектирование: ваш путеводная звезда

**Доменно-ориентированное проектирование (DDD)** предоставляет наиболее надежную основу для декомпозиции микросервисов. Концепция **ограниченных контекстов** DDD естественным образом сопоставляется с границами микросервисов. Ограниченный контекст — это область бизнеса, в которой последовательно применяются определенные термины, правила и модели.

В системе электронной коммерции сущность «Клиент» имеет разное значение в разных контекстах. В **контексте продаж** клиент имеет историю покупок, предпочтения и статус лояльности. В **контексте поддержки** клиент имеет билеты, историю проблем и оценки удовлетворенности. В **контексте биллинга** клиент имеет способы оплаты, счета и кредитные лимиты.

Каждый ограниченный контекст должен стать собственным микросервисом со своей моделью данных. Сущность «Клиент» может быть представлена по-разному в каждом сервисе, оптимизирована под конкретные потребности этого сервиса.

### Определение границ сервиса

**Начните с бизнес-возможностей**, а не с технических компонентов. Вместо «Сервис базы данных» и «Сервис пользовательского интерфейса» думайте о «Сервисе управления заказами» и «Сервисе инвентаризации». Спросите себя: «Какие бизнес-возможности предоставляет наша система?» Каждая возможность — это потенциальная граница сервиса.

**Ищите шаблоны владения данными**. Сервисы должны владеть своими данными от начала до конца. Если вы заметили, что говорите «Сервис заказов должен читать данные из базы данных пользователей», то вы обнаружили потенциальную проблему с границами. Либо сервис пользователей должен предоставлять API для этих данных, либо эти данные должны принадлежать сервису заказов.

**Рассмотрите структуру команд**. Закон Конвея не является просто описательным — он является предписывающим. Если у вас есть отдельные команды для управления пользователями и обработки заказов, это естественные границы сервисов. Попытки бороться с законом Конвея обычно приводят к организационным трениям и усложнению системы.

**Определите границы транзакций**. Операции, которые должны быть строго согласованными, как правило, должны находиться в одной службе. Если вам часто требуются распределенные транзакции между службами, подумайте, не следует ли объединить эти службы в одну.

### Паттерн «душитель фига»: эволюция от монолитов

Большинство организаций не начинают с микросервисов — они эволюционируют к ним. **Паттерн «душитель»** (названный в честь лианы, которая постепенно охватывает и в конечном итоге заменяет дерево-хозяина) предоставляет систематический подход к этой эволюции.

Вместо того чтобы пытаться переписать все за один раз, вы постепенно извлекаете функциональность из монолита:

1. **Определите ограниченный контекст** внутри монолита, который можно извлечь.
2. **Создайте новый микросервис** параллельно монолиту.
3. **Направьте новую функциональность** в микросервис, сохранив существующую функциональность в монолите.
4. **Постепенно перенесите существующую функциональность** из монолита в микросервис.
5. **Удалите замененную функциональность** из монолита.

Этот паттерн снижает риски и позволяет учиться и корректировать процесс по ходу работы. Вы можете начать с службы только для чтения (например, поиск или рекомендации), прежде чем приступать к более сложным транзакционным сервисам.

### Разветвление по абстракции: управление переходом

**Разветвление по абстракции** помогает управлять техническими аспектами извлечения. Вместо прямого вызова монолитного кода вы вводите уровень абстракции, который может направлять запросы либо в монолит, либо в новый сервис. Это позволяет постепенно мигрировать и легко откатываться в случае возникновения проблем.
```
// До
orderService.processOrder(order)

// Во время миграции — уровень абстракции
orderProcessor.processOrder(order) // Маршрутизация к монолиту или микросервису

// После
orderMicroservice.processOrder(order)
```

### Стратегии декомпозиции баз данных

Одной из самых больших проблем при извлечении микрослужб является работа с общими базами данных. Помочь могут несколько шаблонов:

**База данных для каждого сервиса**: идеальное конечное состояние, при котором каждый сервис имеет свою собственную базу данных. Это может потребовать денормализации данных и принятия конечной согласованности между сервисами.

**Антипаттерн общей базы данных**: несколько сервисов, использующих одну и ту же базу данных. Хотя иногда это необходимо во время перехода, это связывает сервисы на уровне данных и должно быть временным.

**Представления базы данных**: создайте представления, которые отображают данные в формате, ожидаемом каждой службой, сохраняя при этом общую базовую схему. Это может быть полезным промежуточным шагом.

**Использование событий для декомпозиции**: используйте события для синхронизации данных между службами во время декомпозиции. Монолит публикует события об изменениях данных, а новые службы могут создавать свои собственные модели данных, потребляя эти события.

## Технологический стек, делающий микросервисы возможными

Микросервисы стали практичными только после того, как созрели поддерживающие технологии. Конвергенция контейнеров, оркестрации, облачных вычислений и инструментов наблюдаемости превратила распределенные системы из академической курьезы в производственную реальность.

### Оркестрация контейнеров и сервисная сетка

**Kubernetes** стал основой для развертывания микросервисов, обрабатывая обнаружение сервисов, балансировку нагрузки, проверки работоспособности и постепенное развертывание. Его декларативная модель означает, что вы описываете желаемое состояние, а Kubernetes поддерживает его — перезапускает сбоившиеся сервисы, масштабирует под нагрузкой, перепланирует рабочие нагрузки.

**Сервис-меши**, такие как Istio, Linkerd и Consul Connect, добавляют шаблоны взаимодействия между сервисами — повторные попытки, прерывание цепочки, наблюдаемость — на уровне инфраструктуры, а не в коде приложения.

### Автоматизация облачных вычислений и инфраструктуры

**Управляемые облачные сервисы** сделали внедрение микросервисов доступным для всех. AWS, Google Cloud и Azure предоставляют управляемые Kubernetes, базы данных, очереди сообщений и бессерверные вычисления, которые устраняют операционные издержки.

Инструменты **Infrastructure as Code**, такие как Terraform, и платформы GitOps, такие как ArgoCD, обеспечивают согласованное и воспроизводимое развертывание в различных средах. Ручное управление инфраструктурой становится невозможным в масштабах микросервисов.

### Наблюдаемость и развертывание

**Распределенное отслеживание** (Jaeger, Zipkin) и **сбор метрик** (Prometheus, Grafana) обеспечивают видимость поведения системы за пределами сервисов. «Три столпа» — метрики, логи и трассировки — становятся необходимыми для отладки распределенных сбоев.

**Независимые конвейеры CI/CD** позволяют каждому сервису создаваться, тестироваться и развертываться независимо. Прогрессивные методы доставки, такие как канарские релизы и флаги функций, снижают риски развертывания.

## Тестирование: переосмысление обеспечения качества в распределенных системах

Тестирование микросервисов ставит перед разработчиками задачи, принципиально отличные от тестирования монолитных приложений. Распределенная природа вводит сетевые границы, зависимости между службами и режимы сбоев, которые не существуют в однопроцессных приложениях. Понимание того, как проводить тестирование эффективно, становится критически важным для поддержания уверенности в надежности системы.

### Тестовая пирамида на практике
![[test_pyramid.png]]
Классическая тестовая пирамида — модульные тесты в основании, интеграционные тесты в середине и сквозные тесты на вершине — остается актуальной, но требует адаптации для микросервисов. **Модульные тесты** остаются в основном неизменными, тестируя отдельные функции и классы изолированно с теми же быстрыми циклами обратной связи, которые вы ожидаете.
**Тесты сервисов** становятся более важными в архитектуре микросервисов. Эти тесты проверяют поведение отдельного микросервиса, запуская сервис в изоляции с отключенными внешними зависимостями. Они дают уверенность в том, что ваш сервис работает правильно, без сложности и хрупкости тестирования нескольких сервисов вместе.

**Сквозные тесты**, охватывающие несколько сервисов, становятся все более проблематичными по мере роста вашей системы. При наличии нескольких сервисов, команд и конвейеров развертывания эти тесты становятся медленными, нестабильными и сложными в обслуживании. Что еще более важно, они создают узкие места в координации, которые подрывают независимую развертываемость, которая делает микросервисы ценными.

### Контракты, ориентированные на потребителя: лучшая альтернатива

**Контракты, ориентированные на потребителя (CDC)**, предлагают убедительную альтернативу широким сквозным тестам. Вместо того чтобы тестировать всю систему вместе, команды потребителей пишут тесты, которые выражают их ожидания относительно поведения службы-производителя. Эти контрактные тесты запускаются изолированно от службы-производителя, выявляя критические изменения без накладных расходов на полное тестирование системы.

Такие инструменты, как **Pact**, позволяют командам программно генерировать эти контракты и обмениваться ими между командами. Когда служба-производитель изменяется, контрактные тесты сразу показывают, какие потребители будут затронуты, что позволяет командам сосредоточиться на обсуждении эволюции API, а не на обнаружении сбоев в производстве.

CDC работают особенно хорошо, потому что они согласуются с границами команд — той же организационной структурой, которая формирует вашу архитектуру микросервисов. Они делают явным то общение, которое уже должно существовать между командами.

### Тестирование в производственной среде: принятие реальности

Возможно, самым значительным изменением в тестировании микросервисов является внедрение тестирования в производственной среде. Сложность распределенных систем означает, что вы не можете обнаружить все потенциальные сбои в предпроизводственной среде. Тестирование в производственной среде становится не просто полезным, но и необходимым.

**Синтетический мониторинг** — это непрерывное автоматическое тестирование производственных систем с использованием поддельных транзакций для проверки правильности работы основных пользовательских сценариев. **Канарейковое развертывание** — это форма тестирования, при которой новые версии постепенно внедряются для подгрупп пользователей. **Флаги функций** позволяют командам тестировать новые функции в производственной среде с контролируемым доступом.

Этот сдвиг отражает более широкое изменение философии: оптимизация **среднего времени восстановления (MTTR)**, а не просто **среднего времени между сбоями (MTBF)**. Вместо того чтобы пытаться предотвратить все сбои, успешные команды создают системы, которые сбои возникают плавно и быстро восстанавливаются.

## Великое переосмысление: микросервисы в 2025 году и далее

Дискуссия о микросервисах значительно созрела с момента их первых энтузиастических внедрений. Сейчас мы находимся в эпохе прагматического осмысления, когда организации честно оценивают, что сработало, что нет и что будет дальше.

### Маятник качается в обратную сторону

Наиболее показательные истории приходят от компаний, которые в первую очередь помогли определить микросервисы. Когда **инженерная команда Prime Video** решила объединить несколько сервисов обратно в монолит для своей системы мониторинга, это не было провалом — это было проявлением зрелости инженерии. Они сохранили микросервисы там, где они имели смысл, и объединили там, где производительность была важнее независимости.

**Segment** переписала свой конвейер обработки событий с микросервисов обратно в монолит, что значительно упростило архитектуру. Даже **Istio**, инструмент, специально разработанный для управления микросервисами, объединил несколько сервисов контрольной плоскости, чтобы снизить сложность эксплуатации.
Эти шаги отражают фундаментальный сдвиг в мышлении. Раннее внедрение микросервисов часто было продиктовано энтузиазмом по поводу новой технологии, а не бизнес-требованиями. Вторая волна характеризуется прагматичным подходом к инженерии: использовать подходящий инструмент для задачи, даже если это означает выбор скучных решений вместо интересных.

### Реальные уроки

**Преждевременное распределение**: многие команды обнаружили, что решают проблемы, которых у них нет. Стартап с пятью инженерами не получает организационных преимуществ от микросервисов — он только усложняет эксплуатацию, не получая никакой выгоды.

**Недооценка эксплуатационных затрат**: каждый микросервис влечет за собой внедрение конвейеров развертывания, мониторинга, ведения журналов и усложнение эксплуатации. Команды обнаружили, что тратят больше времени на управление инфраструктурой, чем на разработку функций.

**Неправильные границы сервисов**: без глубоких знаний в области, команды часто создавали границы сервисов, которые пересекали бизнес-операции, что приводило к появлению многословных, взаимозависимых сервисов, которые было сложнее управлять, чем исходный монолит.

### Современные паттерны: за пределами бинарного мышления

Индустрия вышла за рамки ложной дихотомии «монолит против микросервисов» и перешла к более тонким подходам:

### Модульные монолиты: лучшее из обоих миров

**Модульные монолиты** организуют код в отдельные модули с четкими границами, но развертываются как единое целое. Вы получаете организационные преимущества четкого разделения доменов без операционной сложности распределенных систем. Такие инструменты, как **Spring Modulith**, предоставляют фреймворки для построения модульных монолитов с принудительными границами модулей и поддержкой интеграционного тестирования.

Такие компании, как **Shopify** и **GitHub**, успешно используют этот паттерн, структурируя свои приложения как наборы четко определенных модулей, которые теоретически могут быть извлечены в качестве микросервисов, если это необходимо. **Majestic Monolith** — философия архитектуры программного обеспечения, отстаивающая хорошо спроектированные монолитные приложения, демонстрирует, как хорошо структурированные монолиты могут масштабироваться до значительных размеров, оставаясь при этом поддерживаемыми. Ключевой вывод заключается в том, что многие преимущества, приписываемые микросервисам — четкие границы, ответственность команды, независимая разработка — могут быть достигнуты в рамках монолитной модели развертывания.

### Макросервисы: больше сервисов, меньше проблем

**Макросервисы** представляют собой еще один компромисс — сервисы, которые больше традиционных микросервисов, но меньше монолитов. Вместо отдельных сервисов для аутентификации пользователей, профилей пользователей и настроек пользователей, вы можете иметь один «сервис пользователя», который обрабатывает все функции, связанные с пользователями.

Этот подход сокращает количество сетевых вызовов, упрощает транзакции и снижает операционные затраты, при этом обеспечивая границы сервисов, соответствующие ответственности команды.

### Прагматизм архитектуры: за пределами бинарных выборов

Наиболее опытные команды полностью отошли от споров о монолитных и микросервисных архитектурах. Они создают системы, оптимизированные для достижения бизнес-результатов, а не для архитектурной чистоты. Некоторые части их систем могут представлять собой тесно интегрированные монолиты, где критически важна производительность. Другие части могут быть слабо связанными микросервисами, где независимость команд важнее миллисекунд.

Это не компромисс — это инженерная мудрость. Различные части вашей системы имеют разные требования, разные ограничения и разные компромиссы. Ядро обработки платежей может потребовать тесной интеграции и предсказуемой производительности монолита, в то время как система рекомендаций выиграет от экспериментальной гибкости микросервисов.

### Бессерверная альтернатива

**Бессерверные вычисления** и платформы **Function-as-a-Service (FaaS)** предоставляют многие преимущества микросервисов — независимое развертывание, автоматическое масштабирование, оплата по факту использования — без операционных затрат на управление контейнерами и платформами оркестрации.
Для определенных типов рабочих нагрузок, особенно для событийных и редко используемых сервисов, бессерверные решения могут обеспечить детализацию и независимость микросервисов при гораздо меньшей сложности эксплуатации.


### Микрофронтенды: расширение микросервисов на пользовательский интерфейс

Философия микросервисов естественным образом распространилась на архитектуру фронтенда с помощью **микрофронтендов**, которые разбивают монолитные фронтенд-приложения на более мелкие, независимо развертываемые части, которые могут принадлежать тем же командам, что и бэкенд-сервисы.

Такие инструменты, как **Module Federation** в Webpack, **Single-SPA** и **Bit**, позволяют командам независимо создавать и развертывать фронтенд-компоненты, объединяя их в единый пользовательский интерфейс. Такой подход позволяет командам фронтенд-разработчиков двигаться в ногу с коллегами из бэкенда, выбирая собственные фреймворки, библиотеки и графики развертывания.

Однако микрофронтенды привносят свою сложность в области согласованности, управления общим состоянием и единообразия пользовательского интерфейса. Наиболее успешные реализации сосредоточены на четких границах и надежных системах проектирования, а не на технологиях как таких.

### Среда выполнения приложений: упрощение распределенных систем

**Dapr (Distributed Application Runtime)** — переносимая среда выполнения, управляемая событиями, которая упрощает разработчикам создание отказоустойчивых микросервисных приложений без состояния и с состоянием — представляет собой новую категорию инструментов, предоставляющих строительные блоки для распределенных приложений. Вместо того чтобы каждый сервис реализовывал такие паттерны, как обнаружение сервисов, управление состоянием и обмен сообщениями по модели «pub/sub», Dapr предоставляет их в виде дополнительных сервисов, которые может использовать любое приложение независимо от языка программирования.

Такой подход демократизирует шаблоны распределенных систем, упрощая для команд создание отказоустойчивых микросервисов без глубоких знаний в области распределенных систем. Подобные среды выполнения появляются во всей экосистеме, абстрагируя сложность инфраструктуры распределенных систем.

### Будущее: адаптивные архитектуры

Тенденция заключается в **адаптивных архитектурах**, которые могут развиваться по мере роста организаций. Начните с хорошо структурированного монолита, извлеките службы, когда границы команд станут четкими, и продолжайте развивать архитектуру по мере изменения потребностей.

Появляются инструменты и шаблоны, поддерживающие эту эволюцию: более совершенные инструменты декомпозиции монолитов, стандартизированные интерфейсы служб и платформы, которые могут размещать как монолитные, так и микросервисы.

Ключевой вывод заключается в том, что архитектура — это не одноразовое решение, а непрерывный процесс, который должен соответствовать текущим потребностям вашей организации и одновременно готовить ее к будущим требованиям. Сегодня успешны те компании, которые сознательно внедрили микросервисы, четко понимая все компромиссы и инвестируя в необходимую инфраструктуру.

## Вывод: создание систем, которые масштабируются вместе с вашей организацией

После десятилетия развития микросервисов ключевой вывод прост: архитектура должна служить вашей организации, а не наоборот. Наиболее успешные команды создают адаптивные системы, которые могут эволюционировать от монолитных систем к микросервисам по мере изменения потребностей.

Будущее принадлежит прагматичной инженерии — использованию монолитных систем там, где важна простота, микросервисов там, где важна независимость, и гибридных подходов, которые оптимизируют бизнес-результаты, а не чистоту архитектуры.

Вопрос не в том, выбрать микросервисы или монолитные системы, а в том, как построить системы, которые будут служить вашим пользователям, расширять возможности ваших команд и расти вместе с вашими амбициями.