<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kubernetes Architecture - Enhanced</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: #ffffff;
            border-radius: 20px;
            box-shadow: 0 25px 50px rgba(0,0,0,0.15);
            overflow: hidden;
            position: relative;
        }

        .header {
            text-align: center;
            padding: 40px 20px;
            background: linear-gradient(135deg, #2d3748 0%, #4a5568 100%);
            color: white;
            position: relative;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23ffffff' fill-opacity='0.05'%3E%3Ccircle cx='30' cy='30' r='4'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E") repeat;
        }

        .header h1 {
            font-size: 3em;
            font-weight: 700;
            margin-bottom: 12px;
            position: relative;
            z-index: 1;
        }

        .header p {
            font-size: 1.3em;
            opacity: 0.9;
            position: relative;
            z-index: 1;
            font-weight: 300;
        }

        .diagram-area {
            position: relative;
            padding: 60px 40px;
            background: #f8fafc;
            min-height: 900px;
            background-image: 
                radial-gradient(circle at 25% 25%, #e2e8f0 1px, transparent 1px),
                radial-gradient(circle at 75% 75%, #e2e8f0 1px, transparent 1px);
            background-size: 20px 20px;
        }

        /* Enhanced Components */
        .component {
            position: absolute;
            background: #ffffff;
            border: 2px solid;
            border-radius: 12px;
            padding: 12px 8px;
            text-align: center;
            cursor: pointer;
            transition: none;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            font-weight: 500;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .component:hover {
            z-index: 100;
        }

        .component h3 {
            margin-bottom: 4px;
            font-size: 0.9em;
            font-weight: 600;
            line-height: 1.2;
        }

        .component p {
            font-size: 0.75em;
            opacity: 0.7;
            font-weight: 400;
            line-height: 1.1;
        }

        /* Modern Color Scheme */
        .external {
            border-style: dashed;
            background: linear-gradient(135deg, #f1f5f9, #e2e8f0);
            border-color: #64748b;
            color: #475569;
        }

        /* Control Plane Container */
        .control-plane {
            position: absolute;
            top: 280px;
            left: 200px;
            width: 1000px;
            height: 200px;
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
            border: 3px solid #3b82f6;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(59, 130, 246, 0.15);
        }

        /* Multiple instance indicators */
        .control-plane::after {
            content: '';
            position: absolute;
            top: -8px;
            left: -8px;
            right: 8px;
            bottom: 8px;
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
            border: 2px solid #3b82f6;
            border-radius: 16px;
            z-index: -1;
            opacity: 0.7;
        }

        .control-plane::before {
            content: '';
            position: absolute;
            top: -16px;
            left: -16px;
            right: 16px;
            bottom: 16px;
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
            border: 2px solid #3b82f6;
            border-radius: 16px;
            z-index: -2;
            opacity: 0.4;
        }

        .control-plane-label {
            position: absolute;
            top: -18px;
            left: 30px;
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: white;
            padding: 8px 20px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 1.1em;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
            z-index: 10;
        }

        .control-plane-label::after {
            content: ' (HA)';
            font-size: 0.8em;
            opacity: 0.8;
        }

        /* Data Plane Container */
        .data-plane {
            position: absolute;
            top: 520px;
            left: 200px;
            width: 1000px;
            height: 250px;
            background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%);
            border: 3px solid #22c55e;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(34, 197, 94, 0.15);
        }

        .data-plane::after {
            content: '';
            position: absolute;
            top: -8px;
            left: -8px;
            right: 8px;
            bottom: 8px;
            background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%);
            border: 2px solid #22c55e;
            border-radius: 16px;
            z-index: -1;
            opacity: 0.7;
        }

        .data-plane::before {
            content: '';
            position: absolute;
            top: -16px;
            left: -16px;
            right: 16px;
            bottom: 16px;
            background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%);
            border: 2px solid #22c55e;
            border-radius: 16px;
            z-index: -2;
            opacity: 0.4;
        }

        .data-plane-label {
            position: absolute;
            top: -18px;
            left: 30px;
            background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white;
            padding: 8px 20px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 1.1em;
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.3);
            z-index: 10;
        }

        .data-plane-label::after {
            content: ' (Multiple Nodes)';
            font-size: 0.8em;
            opacity: 0.8;
        }

        /* External Components */
        .kubectl {
            top: 150px;
            left: 50px;
            width: 110px;
            height: 70px;
        }

        .users {
            top: 150px;
            right: 50px;
            width: 110px;
            height: 70px;
        }

        /* Control Plane Components with Modern Colors */
        .api-server {
            top: 320px;
            left: 650px;
            width: 130px;
            height: 70px;
            background: linear-gradient(135deg, #eff6ff, #dbeafe);
            border-color: #3b82f6;
            color: #1e40af;
        }

        .etcd {
            top: 180px;
            left: 650px;
            width: 130px;
            height: 70px;
            background: linear-gradient(135deg, #fef3c7, #fde68a);
            border-color: #f59e0b;
            color: #92400e;
        }

        .scheduler {
            top: 320px;
            right: 220px;
            width: 130px;
            height: 70px;
            background: linear-gradient(135deg, #fae8ff, #f3e8ff);
            border-color: #a855f7;
            color: #7c2d12;
        }

        .controller-manager {
            top: 400px;
            left: 250px;
            width: 160px;
            height: 70px;
            background: linear-gradient(135deg, #d1fae5, #a7f3d0);
            border-color: #10b981;
            color: #065f46;
        }

        .cloud-controller {
            top: 400px;
            right: 200px;
            width: 160px;
            height: 70px;
            background: linear-gradient(135deg, #fce7f3, #fbcfe8);
            border-color: #ec4899;
            color: #9d174d;
        }

        /* Data Plane Components */
        .kubelet {
            top: 560px;
            left: 250px;
            width: 130px;
            height: 70px;
            background: linear-gradient(135deg, #eff6ff, #dbeafe);
            border-color: #3b82f6;
            color: #1e40af;
        }

        .kube-proxy {
            top: 560px;
            right: 220px;
            width: 130px;
            height: 70px;
            background: linear-gradient(135deg, #ecfdf5, #d1fae5);
            border-color: #22c55e;
            color: #14532d;
        }

        .container-runtime {
            top: 700px;
            left: 620px;
            width: 180px;
            height: 70px;
            background: linear-gradient(135deg, #fefce8, #fef3c7);
            border-color: #eab308;
            color: #854d0e;
        }

        /* Modern Pod Styling */
        .pod {
            position: absolute;
            width: 65px;
            height: 45px;
            background: linear-gradient(135deg, #e0f2fe, #b3e5fc);
            border: 2px solid #0284c7;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75em;
            font-weight: 600;
            color: #0c4a6e;
            cursor: pointer;
            transition: none;
            box-shadow: 0 4px 12px rgba(2, 132, 199, 0.2);
        }

        .pod:hover {
            z-index: 100;
        }

        .pod1 { top: 600px; left: 580px; }
        .pod2 { top: 600px; left: 670px; }
        .pod3 { top: 600px; left: 760px; }

        /* Connection Lines with Modern Styling */
        .connections-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .connection-line {
            stroke: #64748b;
            stroke-width: 2.5;
            fill: none;
            stroke-dasharray: 12,6;
            opacity: 0.6;
            transition: all 0.3s ease;
        }

        .connection-line:hover {
            opacity: 1;
        }

        .connection-hover {
            stroke: transparent;
            stroke-width: 12;
            fill: none;
            cursor: pointer;
            pointer-events: all;
        }

        .arrow-marker {
            fill: #64748b;
            opacity: 0.6;
        }


        /* Enhanced Tooltip */
        .tooltip {
            position: absolute;
            background: rgba(30, 41, 59, 0.95);
            backdrop-filter: blur(10px);
            color: white;
            padding: 16px 20px;
            border-radius: 12px;
            font-size: 0.9em;
            max-width: 380px;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            box-shadow: 0 20px 40px rgba(0,0,0,0.25);
            line-height: 1.5;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .tooltip.show {
            opacity: 1;
            visibility: visible;
        }

        .tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 12px solid transparent;
            border-right: 12px solid transparent;
            border-top: 12px solid rgba(30, 41, 59, 0.95);
        }

        .tooltip strong {
            color: #60a5fa;
            font-weight: 600;
        }

        .tooltip .relationship {
            color: #34d399;
            font-weight: 500;
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Kubernetes Architecture</h1>
            <p>Interactive overview of components and their relationships</p>
        </div>
        
        <div class="diagram-area">
            <!-- Connection SVG -->
            <svg class="connections-svg">
                <defs>
                    <marker id="arrowhead" markerWidth="12" markerHeight="8" 
                     refX="11" refY="4" orient="auto">
                        <polygon points="0 0, 12 4, 0 8" class="arrow-marker" />
                    </marker>
                </defs>
                
                <!-- kubectl to API Server -->
                <line x1="160" y1="205" x2="650" y2="340" class="connection-line" marker-end="url(#arrowhead)" />
                <line x1="160" y1="205" x2="650" y2="340" class="connection-hover" 
                      data-tooltip="<strong>kubectl → API Server</strong><br><span class='relationship'>Command Interface</span><br>Users interact with Kubernetes through kubectl CLI, which sends authenticated REST API requests to the kube-apiserver for all cluster operations including deployments, scaling, and resource management." />
                
                <!-- API Server to Users -->
                <line x1="780" y1="340" x2="1190" y2="205" class="connection-line" marker-end="url(#arrowhead)" />
                <line x1="780" y1="340" x2="1190" y2="205" class="connection-hover"
                      data-tooltip="<strong>API Server ↔ Users</strong><br><span class='relationship'>Bidirectional Communication</span><br>Users send requests to the API server through various interfaces (kubectl, REST API, web UIs), and the API server responds with cluster state information, operation results, and notifications." />
                
                <!-- etcd to API Server -->
                <line x1="715" y1="250" x2="715" y2="320" class="connection-line" marker-end="url(#arrowhead)" />
                <line x1="715" y1="250" x2="715" y2="320" class="connection-hover"
                      data-tooltip="<strong>etcd ↔ API Server</strong><br><span class='relationship'>Data Persistence</span><br>The API server is the only component that directly communicates with etcd. It reads and writes all cluster state, configuration data, and metadata to ensure consistency." />
                
                <!-- API Server to Scheduler -->
                <line x1="780" y1="355" x2="1000" y2="355" class="connection-line" marker-end="url(#arrowhead)" />
                <line x1="780" y1="355" x2="1000" y2="355" class="connection-hover"
                      data-tooltip="<strong>API Server → Scheduler</strong><br><span class='relationship'>Pod Assignment</span><br>The scheduler watches the API server for newly created pods without assigned nodes and makes optimal placement decisions based on resource requirements and constraints." />
                
                <!-- API Server to Controller Manager -->
                <line x1="665" y1="390" x2="410" y2="435" class="connection-line" marker-end="url(#arrowhead)" />
                <line x1="665" y1="390" x2="410" y2="435" class="connection-hover"
                      data-tooltip="<strong>API Server → Controller Manager</strong><br><span class='relationship'>State Management</span><br>Controllers continuously watch the API server for changes in desired vs actual cluster state and take corrective actions to maintain consistency." />
                
                <!-- API Server to Kubelet -->
                <line x1="665" y1="390" x2="315" y2="560" class="connection-line" marker-end="url(#arrowhead)" />
                <line x1="665" y1="390" x2="315" y2="560" class="connection-hover"
                      data-tooltip="<strong>API Server → Kubelet</strong><br><span class='relationship'>Node Communication</span><br>The kubelet regularly communicates with the API server to receive pod specifications and report node and pod status, ensuring desired state is maintained." />
                
                <!-- Kubelet to Container Runtime -->
                <line x1="380" y1="610" x2="620" y2="725" class="connection-line" marker-end="url(#arrowhead)" />
                <line x1="380" y1="610" x2="620" y2="725" class="connection-hover"
                      data-tooltip="<strong>Kubelet → Container Runtime</strong><br><span class='relationship'>Container Management</span><br>The kubelet instructs the container runtime through CRI (Container Runtime Interface) to pull images, create containers, and manage their complete lifecycle." />
                
                <!-- Container Runtime to Pods -->
                <line x1="680" y1="700" x2="612" y2="645" class="connection-line" marker-end="url(#arrowhead)" />
                <line x1="680" y1="700" x2="612" y2="645" class="connection-hover"
                      data-tooltip="<strong>Container Runtime → Pods</strong><br><span class='relationship'>Pod Execution</span><br>The container runtime creates and manages the actual containers that make up pods, handling resource allocation, networking, and storage mounting." />
                
                <line x1="710" y1="700" x2="702" y2="645" class="connection-line" marker-end="url(#arrowhead)" />
                <line x1="710" y1="700" x2="702" y2="645" class="connection-hover"
                      data-tooltip="<strong>Container Runtime → Pods</strong><br><span class='relationship'>Pod Execution</span><br>The container runtime creates and manages the actual containers that make up pods, handling resource allocation, networking, and storage mounting." />
                
                <line x1="740" y1="700" x2="792" y2="645" class="connection-line" marker-end="url(#arrowhead)" />
                <line x1="740" y1="700" x2="792" y2="645" class="connection-hover"
                      data-tooltip="<strong>Container Runtime → Pods</strong><br><span class='relationship'>Pod Execution</span><br>The container runtime creates and manages the actual containers that make up pods, handling resource allocation, networking, and storage mounting." />
            </svg>

            <!-- Control Plane Container -->
            <div class="control-plane" data-tooltip="<strong>Control Plane (Master Node)</strong><br>The brain of Kubernetes that makes global decisions about the cluster. It manages the overall cluster state, makes scheduling decisions, and exposes the API that all other components use to communicate. Typically runs on dedicated master nodes for high availability.">
                <div class="control-plane-label">Control Plane (Master Node)</div>
            </div>

            <!-- Control Plane Components -->
            <div class="component api-server" data-tooltip="<strong>API Server (kube-apiserver)</strong><br>The central management component that exposes the Kubernetes REST API. It serves as the front-end for the Kubernetes control plane, validates and configures data for API objects, and is the only component that directly communicates with etcd. All communication in the cluster flows through the API server.">
                <h3>API Server</h3>
                <p>kube-apiserver</p>
            </div>

            <div class="component etcd" data-tooltip="<strong>etcd</strong><br>A distributed, reliable key-value store that serves as Kubernetes' backing store for all cluster data. It stores configuration data, state information, and metadata with strong consistency. etcd provides watch capabilities that enable real-time cluster state monitoring and is critical for cluster recovery.">
                <h3>etcd</h3>
                <p>Key-Value Store</p>
            </div>

            <div class="component scheduler" data-tooltip="<strong>Scheduler (kube-scheduler)</strong><br>Watches for newly created pods with no assigned node and selects the most suitable node for them to run on. Makes decisions based on individual and collective resource requirements, hardware/software/policy constraints, affinity and anti-affinity specifications, and data locality.">
                <h3>Scheduler</h3>
                <p>kube-scheduler</p>
            </div>

            <div class="component controller-manager" data-tooltip="<strong>Controller Manager (kube-controller-manager)</strong><br>Runs controller processes that regulate the state of the cluster. Includes Node Controller (manages node lifecycle), Replication Controller (maintains desired replica count), Endpoints Controller (populates service endpoints), and Service Account & Token Controllers (create default accounts and API access tokens).">
                <h3>Controller Manager</h3>
                <p>kube-controller-manager</p>
            </div>

            <div class="component cloud-controller" data-tooltip="<strong>Cloud Controller Manager</strong><br>Embeds cloud-specific control logic, allowing cloud providers to integrate their platforms with Kubernetes. Manages cloud-specific tasks like creating/deleting load balancers, managing cloud routes, and handling node lifecycle events. Only relevant when running on cloud platforms.">
                <h3>Cloud Controller</h3>
                <p>cloud-controller-manager</p>
            </div>

            <!-- Data Plane Container -->
            <div class="data-plane" data-tooltip="<strong>Data Plane (Worker Nodes)</strong><br>The runtime environment where application workloads actually execute. Each worker node contains the necessary services to run pods and is managed by the control plane. Worker nodes can be physical machines or virtual machines, depending on the cluster setup.">
                <div class="data-plane-label">Data Plane (Worker Nodes)</div>
            </div>

            <!-- Data Plane Components -->
            <div class="component kubelet" data-tooltip="<strong>Kubelet</strong><br>The primary node agent that runs on every worker node. It makes sure that containers are running in pods as specified by the PodSpecs. The kubelet takes PodSpecs from the API server and ensures containers described in those PodSpecs are running and healthy. It also reports node and pod status back to the API server.">
                <h3>Kubelet</h3>
                <p>Node Agent</p>
            </div>

            <div class="component kube-proxy" data-tooltip="<strong>Kube Proxy</strong><br>A network proxy that runs on each node and maintains network rules for pod communication. It implements the Kubernetes Service concept by maintaining network rules and performing connection forwarding. Can use iptables, IPVS, or other packet filtering mechanisms to route traffic efficiently.">
                <h3>Kube Proxy</h3>
                <p>Network Proxy</p>
            </div>

            <div class="component container-runtime" data-tooltip="<strong>Container Runtime</strong><br>The software responsible for running containers on each node. Kubernetes supports several runtimes: Docker, containerd, CRI-O, and any implementation of the Kubernetes CRI (Container Runtime Interface). Pulls container images from registries, creates containers, manages their lifecycle, and provides isolation.">
                <h3>Container Runtime</h3>
                <p>Docker/containerd/CRI-O</p>
            </div>

            <!-- External Components -->
            <div class="component external kubectl" data-tooltip="<strong>kubectl</strong><br>The command-line interface for running commands against Kubernetes clusters. It communicates with the API server using the Kubernetes API, allowing users to deploy applications, inspect and manage cluster resources, view logs, and troubleshoot applications. Essential tool for cluster administration.">
                <h3>kubectl</h3>
                <p>CLI Tool</p>
            </div>

            <div class="component external users" data-tooltip="<strong>Users/Clients</strong><br>External entities that interact with the Kubernetes cluster including developers, system administrators, CI/CD pipelines, monitoring systems, and custom applications. They access Kubernetes through various interfaces like kubectl, web dashboards, or direct API calls using authentication tokens.">
                <h3>Users</h3>
                <p>Clients</p>
            </div>

            <!-- Pods -->
            <div class="pod pod1" data-tooltip="<strong>Pod</strong><br>The smallest deployable unit in Kubernetes. A pod encapsulates one or more tightly coupled containers that share the same network IP address, storage volumes, and lifecycle. Containers within a pod can communicate using localhost and share mounted file systems. Pods are ephemeral and managed by higher-level controllers.">Pod</div>
            <div class="pod pod2" data-tooltip="<strong>Pod</strong><br>The smallest deployable unit in Kubernetes. A pod encapsulates one or more tightly coupled containers that share the same network IP address, storage volumes, and lifecycle. Containers within a pod can communicate using localhost and share mounted file systems. Pods are ephemeral and managed by higher-level controllers.">Pod</div>
            <div class="pod pod3" data-tooltip="<strong>Pod</strong><br>The smallest deployable unit in Kubernetes. A pod encapsulates one or more tightly coupled containers that share the same network IP address, storage volumes, and lifecycle. Containers within a pod can communicate using localhost and share mounted file systems. Pods are ephemeral and managed by higher-level controllers.">Pod</div>

        </div>
    </div>

    <!-- Tooltip element -->
    <div class="tooltip" id="tooltip"></div>

    <script>
        // Simple tooltip functionality
        const tooltip = document.getElementById('tooltip');
        const tooltipElements = document.querySelectorAll('[data-tooltip]');

        tooltipElements.forEach(element => {
            element.addEventListener('mouseenter', (e) => {
                const tooltipText = e.target.getAttribute('data-tooltip');
                tooltip.innerHTML = tooltipText;
                tooltip.classList.add('show');
            });

            element.addEventListener('mousemove', (e) => {
                const rect = tooltip.getBoundingClientRect();
                let left = e.pageX + 20;
                let top = e.pageY - 10;
                
                // Smart positioning to keep tooltip on screen
                if (left + rect.width > window.innerWidth - 20) {
                    left = e.pageX - rect.width - 20;
                }
                if (top < 20) {
                    top = e.pageY + 30;
                }
                if (top + rect.height > window.innerHeight - 20) {
                    top = window.innerHeight - rect.height - 20;
                }
                
                tooltip.style.left = left + 'px';
                tooltip.style.top = top + 'px';
            });

            element.addEventListener('mouseleave', () => {
                tooltip.classList.remove('show');
            });
        });
    </script>
</body>
</html>