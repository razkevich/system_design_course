# Аутентификация и авторизация: основные концепции безопасности

Аутентификация и авторизация представляют собой важнейшие механизмы безопасности в современных системах, обрабатывающих пользовательские данные. Хотя эти концепции кажутся схожими, они решают разные задачи безопасности при проектировании систем.

**Аутентификация** проверяет личность: подтверждает, что пользователи являются теми, за кого себя выдают, путем проверки учетных данных.

**Авторизация** контролирует доступ: определяет, к чему аутентифицированные пользователи могут получить доступ или что они могут выполнять в системе, исходя из их разрешений и ролей.

Оба этих уровня безопасности имеют решающее значение: сбои в аутентификации позволяют подделать личность, а сбои в авторизации приводят к несанкционированному доступу к данным. Оба сценария создают серьезные уязвимости в безопасности, которые могут иметь серьезные последствия для бизнеса.

## Как мы подтверждаем личность: краткая история о том, как не стать жертвой хакеров

### Эволюция методов аутентификации

Ранние методы аутентификации основывались на простых комбинациях имени пользователя и пароля, что было достаточно, когда системы требовали физического доступа. Появление сетевых подключений и систем, доступных через Интернет, потребовало более сложных подходов к аутентификации для борьбы с расширенными векторами атак.

**Базовая аутентификация** передавала учетные данные в виде обычного текста с каждым запросом, создавая значительные уязвимости в безопасности из-за раскрытия учетных данных во время передачи по сети.

**Дайджест-аутентификация** пыталась решить эту очевидную проблему путем хеширования паролей перед их отправкой. Это было лучше, чем ничего, но все равно не идеально — хакеры по-прежнему могли использовать радужные таблицы для взлома этих хешей, а остальные данные по-прежнему передавались без защиты.

**Аутентификация на основе токенов** преобразовала безопасность, отделив проверку учетных данных от постоянного доступа. Пользователи проходят аутентификацию один раз, чтобы получить токен, который авторизует последующие запросы. **Ротация токенов** повышает безопасность за счет автоматических циклов обновления токенов (обычно 15-60 минут), выдавая новые токены и делая предыдущие недействительными. Производственные системы реализуют механизмы обновления токенов для поддержания сеансов пользователей без повторной аутентификации.

**Многофакторная аутентификация (MFA)** пошла еще дальше, требуя нескольких доказательств: что-то, что вы знаете (пароль), что-то, что у вас есть (ваш телефон), а иногда и что-то, что вы есть (ваш отпечаток пальца). Внезапно кража только вашего пароля перестала быть достаточной.

### Протоколы, которые все действительно используют

Современная аутентификация основана на стандартизированных протоколах, которые обеспечивают безопасную, взаимосовместимую аутентификацию в различных системах и приложениях.

**SAML (Security Assertion Markup Language)** предоставляет аутентификационные утверждения на основе XML, оптимизированные для корпоративных сред единого входа (SSO). SAML обеспечивает беспрепятственный доступ к нескольким корпоративным приложениям после первоначальной аутентификации.

**OAuth 2.0** позволяет осуществлять авторизацию третьих сторон без обмена учетными данными, что часто используется для реализации входа через социальные сети. Хотя OAuth 2.0 в первую очередь предназначен для авторизации, он часто адаптируется для целей аутентификации. Производственные реализации поддерживают несколько типов предоставления: потоки кодов авторизации для веб-приложений и потоки JWT bearer для надежной аутентификации между службами.

**OpenID Connect (OIDC)** расширяет OAuth 2.0 стандартизированными функциями идентификации, предоставляя как токены доступа для авторизации API, так и токены идентификации для аутентификации. OIDC обеспечивает надежную реализацию социального входа, используя установленных поставщиков идентификации и сохраняя стандарты безопасности.

В корпоративных средах обычно используются каталоги **LDAP** для централизованного хранения информации о пользователях, **Active Directory** для комплексного управления идентификацией Microsoft и **Kerberos** для сетевой аутентификации без повторного ввода учетных данных. Эти системы интегрируются через SAML, чтобы обеспечить беспрепятственный доступ на всех корпоративных платформах.

Выбор протокола зависит от конкретных архитектурных требований и организационного контекста:

- **SAML** оптимизирован для сценариев SSO в корпоративной среде с установленной инфраструктурой каталогов
- **OAuth 2.0 + OIDC** подходит для современных веб-приложений/мобильных приложений и архитектур на основе API
- **Корпоративные системы** (LDAP, AD, Kerberos) обслуживают организации со сложной иерархией пользователей и требованиями к интеграции устаревших систем

## Авторизация: контроль доступа после аутентификации

### Эволюция контроля доступа

После успешной аутентификации системы должны определять права пользователей и привилегии доступа с помощью различных моделей авторизации.

Ранние системы использовали **списки контроля доступа (ACL)**, которые напрямую сопоставляли пользователей с правами доступа к ресурсам. Этот подход не обеспечивает масштабируемость при управлении тысячами пользователей и миллионами ресурсов.

**Контроль доступа на основе ролей (RBAC)** улучшает масштабируемость за счет группирования разрешений по ролям (редактор, просматривающий, администратор) и назначения пользователям соответствующих ролей. Основные платформы, включая AWS IAM и Kubernetes, реализуют RBAC для удобного управления разрешениями.

**Контроль доступа на основе атрибутов (ABAC)** оценивает несколько атрибутов для принятия решений об авторизации: идентичность пользователя, характеристики ресурса, контекст среды (время, местоположение, устройство). Облачные платформы реализуют ABAC с помощью условных политик, а такие инструменты, как Open Policy Agent (OPA), предоставляют инфраструктуру для управления политиками.

### Авторизация в современных приложениях

**SAML** утверждения включают в себя как проверку аутентификации, так и атрибуты авторизации. Информация о ролях, передаваемая через SAML-ответы, информирует принимающие приложения о разрешениях пользователей и уровнях доступа.

**OAuth 2.0** реализует точную авторизацию API через **области действия**, которые определяют конкретные наборы разрешений. Приложения запрашивают определенные области действия во время авторизации, что позволяет ограничить доступ без обмена учетными данными между службами.

OAuth 2.0 определяет несколько типов предоставления для различных сценариев авторизации:

- **Предоставление кода авторизации**: стандартный веб-поток (перенаправление на вход, возврат с кодом, обмен на токен)
- **Неявное предоставление**: в основном устарело, поскольку было недостаточно безопасным
- **Предоставление учетных данных клиента**: для случаев, когда приложения общаются друг с другом без участия человека
- **Предоставление пароля владельца ресурса**: как правило, плохая идея, если вы не доверяете приложению

**PKCE (Proof Key for Code Exchange)** повышает безопасность OAuth 2.0 для мобильных и одностраничных приложений, предоставляя криптографическое подтверждение подлинности клиента на протяжении всего процесса авторизации.

## Соображения по внедрению в производственную среду

Практическая реализация аутентификации и авторизации требует решения вопросов управления сессиями, обработки токенов и безопасности в производственных средах.

### Стратегии управления сессиями

Безсостоятельный характер HTTP требует тщательного подхода к поддержанию контекста пользователя между запросами:

### Аутентификация на основе токенов

Аутентификация на основе токенов стала предпочтительным подходом для современных веб-приложений, предлагая ряд преимуществ по сравнению с традиционными методами на основе сессий:

**JSON Web Tokens (JWT)** — это автономные токены, которые содержат информацию о пользователе и заявления. Они состоят из трех частей: заголовка, определяющего алгоритм, полезной нагрузки, содержащей заявления, и подписи для проверки. JWT могут быть:

- **Самоподписанные токены**: приложение проверяет токен с помощью общего секретного или открытого ключа, что устраняет необходимость поиска в базе данных при каждом запросе. Токены идентификации OpenID Connect (OIDC) являются ярким примером — эти самоподписанные JWT встраивают заявки, такие как `sub` (идентификатор пользователя), `email`, `name` и `exp` (срок действия), непосредственно в токен и обычно подписываются с помощью RS256 (RSA с SHA-256), что делает их безсостоятельными и быстрыми для проверки.
- **Непрозрачные токены**: случайные строки, не содержащие читаемой информации — сервер должен проверять их, обращаясь к серверу авторизации. В то время как токены идентификации OIDC (которые подтверждают вашу личность) являются JWT, токены доступа OAuth 2.0 (которые предоставляют разрешение на вызов API) часто являются непрозрачными, и OAuth 2.0 изначально предполагал использование непрозрачных токенов. Личные токены доступа GitHub и многие ключи API используют этот формат. Компромисс очевиден: вы получаете возможность мгновенной отмены и лучшую безопасность (поскольку токен ничего не раскрывает в случае кражи), но за счет задержки сети при каждой проверке.

**Подходы к проверке сервера** включают:

- **Проверка без сохранения состояния**: использование криптографических подписей для проверки целостности токена без хранения на стороне сервера
- **Интроспекция токена**: запрос к серверу авторизации для проверки токенов и получения связанных метаданных
- **Гибридные подходы**: сочетание локальной проверки с периодической проверкой на сервере для оптимальной производительности и безопасности
## Авторизация: контроль доступа после аутентификации

### Эволюция контроля доступа

После успешной аутентификации системы должны определять права пользователей и привилегии доступа с помощью различных моделей авторизации.

Ранние системы использовали **списки контроля доступа (ACL)**, которые напрямую сопоставляли пользователей с правами доступа к ресурсам. Этот подход не обеспечивает масштабируемость при управлении тысячами пользователей и миллионами ресурсов.

**Контроль доступа на основе ролей (RBAC)** улучшает масштабируемость за счет группирования разрешений по ролям (редактор, просматривающий, администратор) и назначения пользователям соответствующих ролей. Основные платформы, включая AWS IAM и Kubernetes, реализуют RBAC для удобного управления разрешениями.

**Контроль доступа на основе атрибутов (ABAC)** оценивает несколько атрибутов для принятия решений об авторизации: идентичность пользователя, характеристики ресурса, контекст среды (время, местоположение, устройство). Облачные платформы реализуют ABAC с помощью условных политик, а такие инструменты, как Open Policy Agent (OPA), предоставляют инфраструктуру для управления политиками.

### Авторизация в современных приложениях

**SAML** утверждения включают в себя как проверку аутентификации, так и атрибуты авторизации. Информация о ролях, передаваемая через SAML-ответы, информирует принимающие приложения о разрешениях пользователей и уровнях доступа.

**OAuth 2.0** реализует точную авторизацию API через **области действия**, которые определяют конкретные наборы разрешений. Приложения запрашивают определенные области действия во время авторизации, что позволяет ограничить доступ без обмена учетными данными между службами.

OAuth 2.0 определяет несколько типов предоставления для различных сценариев авторизации:

- **Предоставление кода авторизации**: стандартный веб-поток (перенаправление на вход, возврат с кодом, обмен на токен)
- **Неявное предоставление**: в основном устарело, поскольку было недостаточно безопасным
- **Предоставление учетных данных клиента**: для случаев, когда приложения общаются друг с другом без участия человека
- **Предоставление пароля владельца ресурса**: как правило, плохая идея, если вы не доверяете приложению

**PKCE (Proof Key for Code Exchange)** повышает безопасность OAuth 2.0 для мобильных и одностраничных приложений, предоставляя криптографическое подтверждение подлинности клиента на протяжении всего процесса авторизации.

## Соображения по внедрению в производственную среду

Практическая реализация аутентификации и авторизации требует решения вопросов управления сессиями, обработки токенов и безопасности в производственных средах.

### Стратегии управления сессиями

Безсостоятельный характер HTTP требует тщательного подхода к поддержанию контекста пользователя между запросами:

### Аутентификация на основе токенов

Аутентификация на основе токенов стала предпочтительным подходом для современных веб-приложений, предлагая ряд преимуществ по сравнению с традиционными методами на основе сессий:

**JSON Web Tokens (JWT)** — это автономные токены, которые содержат информацию о пользователе и заявления. Они состоят из трех частей: заголовка, определяющего алгоритм, полезной нагрузки, содержащей заявления, и подписи для проверки. JWT могут быть:

- **Самоподписанные токены**: приложение проверяет токен с помощью общего секретного или открытого ключа, что устраняет необходимость поиска в базе данных при каждом запросе. Токены идентификации OpenID Connect (OIDC) являются ярким примером — эти самоподписанные JWT встраивают заявки, такие как `sub` (идентификатор пользователя), `email`, `name` и `exp` (срок действия), непосредственно в токен и обычно подписываются с помощью RS256 (RSA с SHA-256), что делает их безсостоятельными и быстрыми для проверки.
- **Непрозрачные токены**: случайные строки, не содержащие читаемой информации — сервер должен проверять их, обращаясь к серверу авторизации. В то время как токены идентификации OIDC (которые подтверждают вашу личность) являются JWT, токены доступа OAuth 2.0 (которые предоставляют разрешение на вызов API) часто являются непрозрачными, и OAuth 2.0 изначально предполагал использование непрозрачных токенов. Личные токены доступа GitHub и многие ключи API используют этот формат. Компромисс очевиден: вы получаете возможность мгновенной отмены и лучшую безопасность (поскольку токен ничего не раскрывает в случае кражи), но за счет задержки сети при каждой проверке.

**Подходы к проверке сервера** включают:

- **Проверка без сохранения состояния**: использование криптографических подписей для проверки целостности токена без хранения на стороне сервера
- **Интроспекция токена**: запрос к серверу авторизации для проверки токенов и получения связанных метаданных
- **Гибридные подходы**: сочетание локальной проверки с периодической проверкой на сервере для оптимальной производительности и безопасности

### Другие способы подтвердить свою личность

**Аутентификация на основе сеанса** создает идентификаторы сеанса на стороне сервера, передаваемые через HTTP-cookie. Управление сеансами включает настройку соответствующих контролей срока действия через атрибуты cookie (`Max-Age`, `HttpOnly`, `Secure`) для баланса между удобством использования и требованиями безопасности.

**Ключи API** предоставляют постоянные учетные данные для программного доступа, которые обычно используются для связи между серверами. В отличие от токенов пользователей, ключи API идентифицируют приложения, а не отдельных пользователей, и требуют ручной ротации для поддержания безопасности.

**Аутентификация на основе сертификатов** использует