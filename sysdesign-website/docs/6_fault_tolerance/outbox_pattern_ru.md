# Шаблон «Outbox»

Проблема двойной записи возникает, когда системы должны атомарно обновлять базу данных и публиковать событие в брокер сообщения. Шаблон «Outbox» решает эту проблему, храня события в той же базе данных, что и бизнес-данные, в рамках одной транзакции, обеспечивая согласованность без необходимости распределенных транзакций.

``` mermaid
sequenceDiagram
    participant App as Приложение
    participant DB as База данных&lt;br/>(Заказы + Таблицы Outbox)
    participant OP as Процессор Outbox
    participant MB as Брокер сообщений
    participant Cons as Нижестоящие сервисы

    Note over App,DB: 1. Транзакционная запись
    App->>DB: НАЧАТЬ ТРАНЗАКЦИЮ
    App->>DB: ВСТАВИТЬ бизнес-данные
    App->>DB: ВСТАВИТЬ событие в таблицу outbox
    App->>DB: ЗАФИКСИРОВАТЬ

    Note over OP,MB: 2. Обработка Outbox
    loop Интервал опроса
        OP->>DB: Запросить outbox на неопубликованные события
        DB-->>OP: Вернуть ожидающие события
        OP->>MB: Опубликовать события
        MB-->>OP: Подтверждение
        OP->>DB: Отметить события как опубликованные
    end

    Note over MB,Cons: 3. Доставка событий
    MB->>Cons: Доставить события подписчикам
```

## Как это работает

Вместо того чтобы пытаться координировать две отдельные системы (базу данных и брокер сообщений), вы рассматриваете публикацию событий как часть своей модели данных. При создании заказа вы вставляете как запись заказа, так и запись события в таблицу «outbox», и все это в рамках одной транзакции базы данных.

Таблица «outbox» обычно содержит поля для идентификатора события, типа события, данных полезной нагрузки события, временной метки создания и временной метки обработки, которая начинается с нуля. При обработке заказа ваше приложение вставляет заказ и соответствующее событие в рамках одной транзакции. Прелесть этого подхода в том, что либо обе операции выполняются успешно, либо обе завершаются сбоем — частичного состояния не бывает.

Теперь вам нужно что-то, чтобы фактически опубликовать эти события. Традиционный подход — это **процессор outbox** — фоновый процесс, который опрашивает таблицу outbox в поисках неопубликованных событий. Это может быть простое запланированное задание, которое запускается каждые несколько секунд, запрашивает события, у которых метка времени обработки равна нулю, пытается опубликовать каждое событие в брокере сообщений и помечает успешные публикации как обработанные.

Этот подход с опросом часто критикуют за «неэффективность», но он отличается замечательной надежностью. Он работает с любой базой данных, любым посредником сообщений, а также прост в понимании и отладке. Задержка обычно приемлема для большинства бизнес-сценариев — задержка в обработке событий в несколько секунд часто является вполне допустимой.

Некоторые реализации используют сложные инструменты Change Data Capture (CDC), такие как Debezium, которые отслеживают журнал транзакций базы данных и публикуют события практически в режиме реального времени. Хотя они могут снизить задержку, они значительно усложняют эксплуатацию и привязывают к конкретному поставщику.

## Подход Kafka

Kafka предлагает интересную вариацию этого паттерна благодаря своим транзакционным возможностям. При потреблении сообщений из одной темы и производстве в другую вы можете использовать семантику Kafka «точно один раз», чтобы гарантировать, что потребление и производство сообщений происходят атомарно. Потребитель может зафиксировать свое смещение и произвести новые сообщения в рамках одной транзакции Kafka, достигая гарантий, аналогичных паттерну «исходящие сообщения» базы данных, но полностью в экосистеме Kafka.

Этот подход хорошо работает, когда весь конвейер обработки может оставаться в Kafka, но не работает, когда необходимо обновлять внешние базы данных или координировать работу с системами, не относящимися к Kafka. По сути, это специализированная форма паттерна «outbox», где журнал транзакций Kafka служит одновременно брокером сообщений и «базой данных», в которой хранится состояние транзакций.

## Реальность реализации

Шаблон «outbox» — это не только идеальный вариант. Вам необходимо решить несколько практических проблем, которые часто упускаются из виду в примерах из учебников.

Упорядочение событий может быть сложной задачей. Хотя события вставляются в порядке, сетевые задержки и параллельная обработка означают, что они могут поступать к потребителям не в том же порядке. Если это имеет значение для вашего случая использования, вам может потребоваться включить порядковые номера или временные метки, которые потребители могут использовать для переупорядочения событий.

Со временем становится важным управление хранением. Таблица outbox будет постоянно расти, и вам понадобится стратегия очистки. Некоторые команды удаляют обработанные события по истечении срока хранения, другие архивируют их в холодное хранилище. Главное — иметь план до того, как база данных заполнится.

Дубликаты событий неизбежны при использовании паттерна «outbox», поскольку он обычно обеспечивает семантику доставки «хотя бы один раз». Ваш издатель событий может завершить работу после публикации события, но до его пометки как обработанного, что приведет к повторной публикации. Это означает, что все потребители событий должны быть идемпотентными — они должны корректно обрабатывать одно и то же событие, полученное несколько раз.

Обработка ошибок в издателе имеет решающее значение. Что происходит, когда брокер сообщений не работает? Когда события не могут быть сериализованы? Когда происходит сбой подключения к базе данных во время обновления обработанных событий? Для надежной реализации необходимы логика повторных попыток, очереди мертвых писем и мониторинг для обнаружения сбоев издателя.

## Почему это работает

Шаблон «outbox» успешен, потому что он использует существующие транзакционные гарантии базы данных, а не пытается построить распределенные транзакции между системами. Базы данных очень хорошо поддерживают свойства ACID — почему бы этим не воспользоваться?

Он также обеспечивает естественную отказоустойчивость. Если издатель событий выходит из строя, события безопасно остаются в таблице «outbox», ожидая следующего цикла опроса. Если брокер сообщений временно недоступен, события накапливаются и публикуются, когда он снова становится доступным.

В качестве побочного эффекта паттерн создает контрольный след. Каждое событие, которое когда-либо было сгенерировано, существует в таблице «outbox» (до тех пор, пока вы не очистите ее), что может быть неоценимо для отладки и обеспечения соответствия требованиям.

Возможно, самое важное — это то, что он отделяет вашу основную бизнес-логику от доступности нижестоящих систем. Вы можете обрабатывать заказы, даже если Kafka не работает, зная, что события в конечном итоге будут опубликованы.

Шаблон «outbox» представляет собой прагматичный подход к фундаментальной проблеме распределенных систем. Это не самое элегантное решение, но оно проверено, понятно и надежно — качества, которые в производственных системах важнее элегантности.
