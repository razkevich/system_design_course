# Модульные монолиты

Модульные монолиты сочетают в себе модульность и четкие границы микросервисов с простотой эксплуатации монолитного развертывания. Такие организации, как Shopify, GitHub и Basecamp, успешно внедрили крупномасштабные системы, используя этот подход, добившись автономности команд и четких архитектурных границ, а также избежав сложности распределенных систем.

## Что делает монолит модульным

Разница между модульным монолитом и традиционным монолитом не заключается в способе развертывания — оба являются едиными целыми. Разница заключается в их внутренней организации и дисциплине, с которой поддерживаются границы.

### Модули как первоклассные элементы

В модульном монолите **модули — это не просто папки или пакеты, а архитектурные границы**. Каждый модуль представляет собой отдельную бизнес-возможность со своей собственной моделью данных, бизнес-логикой и четким интерфейсом для остальной части системы. Модуль может обрабатывать управление пользователями, обработку заказов или отслеживание запасов, но делает это как самостоятельная единица.

В отличие от обычных монолитов, модульные монолиты обеспечивают четкие границы между бизнес-доменами за счет организации кода и инструментов. Модули взаимодействуют только через определенные API и полностью владеют своими данными, что позволяет независимым командам разрабатывать модули, сохраняя при этом простоту единого развертывания.

Эти модули взаимодействуют через **четко определенные интерфейсы**, а не через прямые вызовы методов или общий доступ к базе данных. Когда модуль заказов нуждается в информации о пользователе, он не запрашивает ее напрямую из базы данных пользователей, а вызывает API модуля пользователя. Этот интерфейс может быть реализован в виде вызовов методов внутри процесса для повышения производительности, но архитектурная граница остается четкой.

### Принудительные границы с помощью дисциплины и инструментов

Критической задачей модульных монолитов является **принудительное соблюдение границ**. Без сетевых границ, которые естественным образом разделяют микросервисы, возникает соблазн пойти по пути упрощения — напрямую обратиться к базе данных другого модуля или вызвать внутренние методы. Именно здесь дисциплина и инструменты становятся незаменимыми.

Современные фреймворки предоставляют механизмы для обеспечения соблюдения этих границ. **Spring Modulith** предлагает проверку границ модулей на этапе компиляции, гарантируя, что модули взаимодействуют только через назначенные интерфейсы.

### Домен-ориентированное проектирование как основа

Наиболее успешные модульные монолиты выравнивают границы модулей в соответствии с **принципами домен-ориентированного проектирования**. Каждый модуль представляет собой ограниченный контекст — область, в которой последовательно применяются определенные бизнес-концепции, правила и терминология.

В системе электронной коммерции могут быть модули для управления клиентами, обработки заказов, контроля запасов, обработки платежей и координации доставки. Каждый модуль имеет свою собственную модель основных концепций, таких как «клиент» или «продукт», оптимизированную для конкретного случая использования. В модуле управления клиентами представлена подробная информация о клиенте, включая его профиль и предпочтения, а в модуле доставки — только адрес и предпочтения по доставке.

## Шаблоны и стратегии реализации

Создание эффективных модульных монолитов требует целенаправленных шаблонов проектирования, которые поддерживают четкие границы и обеспечивают эффективную коммуникацию между модулями.

### Шестиугольный модульный паттерн

Каждый модуль может быть структурирован с использованием **шестиугольной архитектуры** (порты и адаптеры) с четким разделением бизнес-логики и внешних задач. Основная бизнес-логика модуля находится в центре, окруженная портами, которые определяют интерфейсы для внешней коммуникации с другими модулями, базами данных, API и внешними системами, а также адаптерами, которые реализуют эти интерфейсы.

Этот шаблон особенно хорошо работает в модульных монолитах, поскольку он делает границы явными. Другие модули взаимодействуют с бизнес-логикой только через определенные порты, никогда напрямую с внутренними реализациями.

### Событийно-ориентированная коммуникация внутри монолита

Даже в рамках одного процесса модули могут взаимодействовать через **события**, а не прямые вызовы. Когда заказ выполнен, модуль «Заказ» публикует событие «OrderCompleted», которое могут потреблять модули «Инвентарь», «Уведомления» и «Аналитика».

Этот событийно-ориентированный подход обеспечивает те же преимущества слабой связности, что и микросервисы, сохраняя при этом простоту внутрипроцессной коммуникации. События могут обрабатываться синхронно для обеспечения немедленной согласованности или асинхронно для повышения производительности, в зависимости от бизнес-требований.

### Общий ядро и антикоррупционные слои

Некоторые концепции законно охватывают несколько модулей — идентичность пользователя, общие объекты значений или общие бизнес-правила. Паттерн **Shared Kernel** позволяет модулям зависеть от общих абстракций, сохраняя при этом свою независимость для бизнес-логики.
Когда модулям необходимо взаимодействовать с внешними системами или устаревшими компонентами, которые не следуют четким границам, **антикоррупционные слои** обеспечивают перевод между чистой внутренней моделью модуля и запутанной внешней реальностью.

## Технологическая и инструментальная поддержка

Экосистема инструментов для модульных монолитов значительно созрела, предоставляя конкретную поддержку для построения и обслуживания модульных систем.

### Spring Modulith: проверка архитектуры для Java

**Spring Modulith** привносит в экосистему Spring первоклассную поддержку модульных монолитов. Он предоставляет инструменты для проверки соблюдения границ модулей на этапе компиляции, генерации документации о взаимосвязях между модулями и тестирования модулей в изоляции.

Spring Modulith позволяет разработчикам определять модули как Java-пакеты с явными публичными API. Любая попытка доступа к непубличным компонентам из другого модуля приводит к ошибкам компиляции, что обеспечивает автоматическое соблюдение архитектурных границ.

### .NET и модульный дизайн

Экосистема **.NET** уже давно поддерживает модульный дизайн с помощью сборок и пространств имен. Современный .NET предоставляет дополнительные инструменты, такие как **модификаторы внутренней доступности** и **контроль доступа на уровне сборки**, которые помогают поддерживать границы модулей.

Проекты, такие как **Wolverine** и **MediatR**, предоставляют шаблоны для событийно-ориентированной коммуникации в монолитных системах .NET, обеспечивая слабую связь между модулями при сохранении высокой производительности.

### Шаблоны модулей баз данных

Одним из самых сложных аспектов модульных монолитных систем является управление данными. Несколько шаблонов помогают сохранить границы данных при использовании общей инфраструктуры:

**Схема для каждого модуля**: каждый модуль имеет свою схему базы данных, а отношения внешних ключей существуют только в пределах модуля. Доступ к данным между модулями осуществляется через API модулей, а не через прямые запросы к базе данных.

**Представления базы данных для интеграции**: представления только для чтения могут обеспечить контролируемый доступ к данным между модулями для отчетности и аналитики, сохраняя границы записи через API модулей.

**Исходные события для коммуникации между модулями**: События могут служить как точками интеграции, так и контрольным журналом, обеспечивая чистый способ обмена изменениями состояния между модулями при сохранении автономности.

## Стратегии эволюции: плавное расширение и сокращение

Одним из самых мощных аспектов модульных монолитов является их **эволюционная гибкость**. Они могут расти из простых монолитов и, при необходимости, разделяться на микросервисы — или объединяться обратно из микросервисов, когда операционная сложность становится чрезмерной.

### От монолита к модульному

Путь от традиционного монолита к модульному монолиту обычно начинается с **определения границ домена** в существующем кодовом базе. Этот процесс часто показывает, что система уже имеет естественные швы — области, где обязанности четко разделены, а связь минимальна.

Для этой трансформации хорошо подходит **паттерн «душитель»**. Вместо попытки радикальной реструктуризации команды постепенно извлекают функциональность в четко определенные модули, устанавливая четкие интерфейсы и со временем устраняя прямые зависимости.

### Извлечение модулей в микросервисы

Когда рост организации или технические требования оправдывают операционную сложность микросервисов, хорошо спроектированные модульные монолиты делают переход более плавным. Каждый модуль потенциально может стать независимым сервисом с установленными границами и моделями коммуникации.

Ключевой вывод заключается в том, что **модульные монолиты служат отличной площадкой для микросервисов**. Команды могут экспериментировать с границами сервисов, совершенствовать интерфейсы и наращивать операционные возможности, сохраняя при этом простоту монолитного развертывания. Когда выделение имеет смысл, архитектурная основа уже готова.
### Микросервисы: возвращение к модульным монолитам

Как мы видели на примере таких компаний, как Prime Video и Segment, иногда путь микросервисов ведет обратно к консолидированным архитектурам. Модульные монолиты являются отличной целью для такой консолидации — команды могут сохранить четкие границы и независимые методы разработки, которые они создали, одновременно сократив операционные расходы.

## Преимущества: почему умные команды выбирают модульные монолиты

Преимущества модульных монолитов становятся очевидными при сравнении как с традиционными монолитами, так и с архитектурами микросервисов.

### Простота эксплуатации при сложной архитектуре

**Единая единица развертывания** означает упрощенные конвейеры CI/CD, более простые откаты и снижение накладных расходов на координацию. Необходимо отслеживать одну сборку, координировать одно развертывание и управлять одной средой выполнения. При этом внутренняя архитектура сохраняет четкие границы и разделение задач, что обеспечивает производительность команды.

**Последовательная среда разработки**: разработчики могут запускать всю систему локально, что упрощает отладку и тестирование. Нет необходимости имитировать десятки внешних сервисов или управлять сложной локальной оркестрацией.

### Производительность без компромиссов

**Внутрипроцессная коммуникация** устраняет сетевую задержку и накладные расходы на сериализацию. То, что в архитектуре микросервисов потребовало бы нескольких HTTP-вызовов, в модульном монолите может быть выполнено с помощью эффективных вызовов методов при сохранении архитектурных границ.

**Транзакционная согласованность** между модулями остается простой, когда это необходимо. Бизнес-операции, охватывающие несколько доменов, могут сохранять свойства ACID без сложности распределенных транзакций.

### Производительность и автономность команды

**Четкие границы ответственности** позволяют командам работать над своими модулями независимо, одновременно внося вклад в общий код. Команды могут принимать локальные решения о деталях реализации, соблюдая согласованные интерфейсы.

**Снижение когнитивной нагрузки**: разработчикам нужно понимать интерфейсы модулей, а не сложности распределенных систем. Устраняется ментальная нагрузка, связанная с сетевыми разделами, конечной согласованностью и обнаружением сервисов.

## Проблемы: где модульные монолиты сталкиваются с трудностями

Ни один архитектурный паттерн не является идеальным, и модульные монолиты сталкиваются с собственным набором проблем, которые команды должны тщательно решать.

### Дисциплина границ

Самая большая проблема — **сохранение архитектурных границ без механизмов принудительного выполнения**. В отличие от микросервисов, где сетевые границы обеспечиваются физически, модульные монолиты полагаются на дисциплину команды и инструменты для поддержания разделения.

**Накопление технического долга** может со временем разрушить границы. Без постоянной бдительности, упрощения и удобные решения могут связать модули таким образом, что это подорвет преимущества архитектуры.

**Ограниченная автономия команды**: в отличие от микросервисов, где команды могут независимо выбирать стек технологий, базу данных, стратегию ветвления git и стратегию развертывания, модульные монолиты ограничивают команды общими решениями по инфраструктуре и скоординированными стратегиями ветвления.

### Ограничения масштабирования

Хотя модульные монолиты могут значительно масштабироваться, в конечном итоге они сталкиваются с **ограничениями ресурсов и команды**. Все модули используют одну и ту же среду выполнения, пространство памяти и цикл развертывания. Для действительно крупных систем или организаций эти ограничения могут стать сдерживающими факторами.

**Координация развертывания** по-прежнему требует определенного уровня координации между командами, особенно в случае изменений схемы базы данных или модификаций интерфейса, которые затрагивают несколько модулей.

### Сложность эволюции

**Крупномасштабная рефакторинг** между модулями может быть сложной задачей. Когда бизнес-требования меняются таким образом, что не соответствуют существующим границам модулей, реструктуризация требует большей координации, чем в слабосвязанных микросервисах.
## Резюме

Модульные монолиты обеспечивают преимущества модульной архитектуры, сохраняя при этом простоту развертывания. Этот подход хорошо подходит для организаций, которым требуются четкие границы без операционной сложности микросервисов. Архитектура эффективно работает, когда масштаб организации не оправдывает накладные расходы на распределенные системы, хотя она требует дисциплинированного поддержания границ и может ограничивать выбор технологий команды. Модульные монолиты могут служить либо долгосрочным архитектурным решением, либо эволюционным шагом к микросервисам при изменении требований к масштабируемости.