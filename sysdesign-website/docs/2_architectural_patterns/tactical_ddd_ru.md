# Тактический доменно-ориентированный дизайн

## Обзор

Тактический доменно-ориентированный дизайн предоставляет строительные блоки для реализации богатых доменных моделей в ограниченных контекстах. В то время как стратегический DDD фокусируется на идентификации ограниченных контекстов и понимании их взаимосвязей в рамках предприятия, тактический DDD занимается реализацией выразительных доменных моделей в этих контекстах.

Многие корпоративные приложения полагаются на простые структуры данных, которые содержат состояние, но минимальное поведение:

```java
public class Order {
    private String id;
    private String customerId;
    private List<OrderItem> items;
    private OrderStatus status;
    private BigDecimal totalAmount;
    
    // getters and setters...
}
```

Этот подход «Java Bean» создает простые структуры данных, которые хорошо работают с фреймворками, но не обладают богатым поведением и бизнес-правилами, которые определяют домен. Вся бизнес-логика концентрируется в классах сервисов, что приводит к тому, что Domain-Driven Design называет «анемичными доменными моделями».

Тактические паттерны DDD преобразуют эти простые хранилища данных в богатые объекты, которые инкапсулируют как данные, так и поведение, создавая доменные модели, которые действительно представляют бизнес-концепции и обеспечивают соблюдение бизнес-правил.

## Проблема с анемичными доменными моделями

Анемичные доменные модели — это классы, которые содержат данные, но практически не имеют поведения. По сути, это превознесенные объекты передачи данных (DTO) с бизнес-логикой, разбросанной по различным сервисным классам. Хотя этот подход работает, он упускает возможности для создания более поддерживаемого и выразительного кода.

Типичный сервис обработки заказов демонстрирует этот паттерн:

```java
@Service
public class OrderService {
    public void processOrder(Order order) {
        if (order.getStatus() != OrderStatus.PENDING) {
            throw new IllegalStateException(«Only pending orders can be processed»);
        }
        
        BigDecimal total = BigDecimal.ZERO;
        for (OrderItem item : order.getItems()) {
            total = total.add(item.getPrice().multiply(new BigDecimal(item.getQuantity())));
        }
        order.setTotalAmount(total);
        order.setStatus(OrderStatus.CONFIRMED);
    }
}
```

Такая конструкция отделяет бизнес-правила от данных, с которыми они работают, что снижает обнаруживаемость и поддерживаемость доменной логики.

## Тактический DDD: построение богатых доменных моделей

## Основные принципы

Тактический DDD создает доменные объекты, которые инкапсулируют как данные, так и поведение, размещая бизнес-логику рядом с данными, с которыми она работает. Этот подход не устраняет все сервисы, но гарантирует, что бизнес-логика находится в подходящих местах.

В рамках ограниченного контекста тактические паттерны преобразуют простые структуры данных в богатые доменные объекты. Эти объекты, будь то сущности или объекты-значения, инкапсулируют бизнес-логику и сохраняют владение своим состоянием.

## Сущности: объекты с идентичностью

Сущности представляют доменные концепции, которые имеют четкую идентичность, сохраняющуюся во времени. В тактическом DDD сущности должны содержать свою основную бизнес-логику, а не просто раскрывать свое состояние.

```java
public class Order {
    private final OrderId id;
    private final CustomerId customerId;
    private final List<OrderItem> items;
    private OrderStatus status;
    private Money totalAmount;
    
    public Order(OrderId id, CustomerId customerId) {
        this.id = Objects.requireNonNull(id);
        this.customerId = Objects.requireNonNull(customerId);
        this.items = new ArrayList<>();
        this.status = OrderStatus.PENDING;
        this.totalAmount = Money.ZERO;
    }
    
    public void addItem(Product product, int quantity) {
        if (status != OrderStatus.PENDING) {
            throw new IllegalStateException(«Cannot modify confirmed order»);
        }
        
        OrderItem item = new OrderItem(product, quantity);
        items.add(item);
        recalculateTotal();
    }
    
    public void confirm() {
        if (items.isEmpty()) {
            throw new IllegalStateException(«Невозможно подтвердить пустой заказ»);
        }
        if (status != OrderStatus.PENDING) {
            throw new IllegalStateException(«Заказ уже обработан»);
        }
        
        this.status = OrderStatus.CONFIRMED;
    }
    
    private void recalculateTotal() {
        this.totalAmount = items.stream()
            .map(OrderItem::getSubtotal)
            .reduce(Money.ZERO, Money::add);
    }
    
    // Геттеры для доступа к необходимым данным (нет сеттеров для полей, критичных для бизнеса)
    public OrderId getId() { return id; }
    public OrderStatus getStatus() { return status; }
    public Money getTotalAmount() { return totalAmount; }
}
```

Бизнес-правила встроены в сущность, что позволяет заказу проверять переходы состояний и поддерживать инварианты. Это представляет собой основной принцип тактического DDD: преобразование пассивных держателей данных в активные объекты домена, которые понимают и обеспечивают соблюдение бизнес-правил.

## Объекты-значения: богатые типы данных

Объекты-значения преобразуют обработку данных, группируя связанные свойства в связные, значимые объекты с инкапсулированным поведением, заменяя распространение примитивных типов по всему коду.

### От примитивной одержимости к типам домена

Сигнатуры методов демонстрируют преобразование от подходов с преобладанием примитивных типов:

**До объектов-значений:**
```java
calculateShipping(BigDecimal amount, String currency, String street, String city, String zipCode, String country)
```

**С объектами-значениями:**
```java
calculateShipping(Money price, Address destination)
```

Объекты-значения выходят за рамки простой группировки, инкапсулируя поведение, которое в противном случае потребовало бы использования утилит или сервисов.

### Инкапсуляция поведения

Объекты-значения содержат бизнес-логику, специфичную для домена. Объект `Money` предоставляет арифметические операции (сложение, умножение, сравнение), а объект `Address` обрабатывает валидацию и расчет расстояний. Это поведение остается близким к данным, с которыми оно работает.

### Преимущества

- **Типовая безопасность**: предотвращает неверную передачу параметров (ID клиента vs. ID заказа)
- **Выразительность**: самодокументирующиеся сигнатуры методов
- **Проверка**: применение бизнес-правил при создании объекта
- **Неизменяемость**: новые экземпляры для изменений, предотвращающие случайные модификации
- **Тестируемость**: изолированная бизнес-логика для модульного тестирования

### Рекомендации по применению

Создавайте объекты-значения, чтобы:
- Заменить примитивные типы, представляющие концепции домена (адреса электронной почты, номера телефонов, денежные суммы)
- Группировать связанные поля, которые передаются вместе (компоненты адреса, координаты)
- Инкапсулировать доменно-специфическое поведение (вычисления, валидации, форматирование)

Объекты-значения создают богатый словарный запас доменных концепций, которые четко выражают бизнес-намерения, преобразуя кодовые базы из наборов слабо связанных примитивов в связные доменные модели.

## Доменные службы: сложная бизнес-логика

Не вся бизнес-логика относится к сущностям или объектам-значениям. Доменные службы обрабатывают операции, которые затрагивают несколько сущностей или представляют концепции домена, которые не вписываются в один объект.

```java
@DomainService
public class OrderPricingService {
    private final DiscountCalculator discountCalculator;
    private final TaxCalculator taxCalculator;
    
    public OrderTotal calculateTotal(Order order, Customer customer) {
        Money subtotal = order.getSubtotal();
        Money discount = discountCalculator.calculateDiscount(order, customer);
        Money tax = taxCalculator.calculateTax(subtotal.subtract(discount), customer.getLocation());
        
        return new OrderTotal(subtotal, discount, tax);
    }
}
```

Доменные службы координируют работу между сущностями и объектами-значениями, поддерживая организованную и тестируемую сложную бизнес-логику.

### Обязанности службы

Хотя сущности содержат основную бизнес-логику, для некоторых операций требуются доменные службы:

- **Операции с несколькими сущностями**: логика, которая включает в себя несколько агрегатов или сущностей. Например, перемещение запасов между складами включает в себя несколько агрегатов `Warehouse` и должно обрабатываться службой `InventoryTransferService`.

- **Интеграция с внешними системами**: правила, требующие данных от внешних служб. `CreditCheckService` может проверять кредитоспособность клиента, вызывая API внешнего кредитного бюро, прежде чем разрешать крупные заказы.

- **Сложные вычисления, включающие несколько контекстов**: логика ценообразования, учитывающая уровень клиента, категории продуктов, сезонные скидки и региональные налоги, может быть слишком сложной для одной сущности и лучше подходит для `PricingService`.

- **Доменные политики, которые часто меняются**: правила, которые могут изменяться в зависимости от условий бизнеса. `ShippingPolicyService` может определять варианты доставки на основе текущей доступности перевозчика и бизнес-правил, которые меняются в зависимости от сезона.

- **Операции, чувствительные к производительности**: вычисления, требующие кэширования, пакетной обработки или специализированных алгоритмов. `RecommendationService` может использовать модели машинного обучения, которые слишком тяжелы для отдельных сущностей.

**Принцип**: сущности сосредоточены на основной идентичности и непосредственных бизнес-правилах, а сервисы занимаются координацией, интеграцией и сложными междисциплинарными вопросами.

## Агрегаты: границы согласованности

Агрегат — это кластер связанных сущностей и объектов-значений, которые рассматриваются как единое целое для изменения данных. В рамках ограниченного контекста агрегаты определяют границы согласованности — все внутри агрегата должно оставаться согласованным, а сам агрегат является единственным способом, с помощью которого внешний код может изменять этот кластер.

Агрегат имеет одну назначенную «корневую» сущность, которая служит в качестве контролера доступа. Внешние объекты могут ссылаться на агрегат и изменять его только через его корень, никогда не обращаясь напрямую к внутренним сущностям. Это гарантирует, что бизнес-правила всегда соблюдаются, а агрегат никогда не попадает в недействительное состояние.

Агрегаты являются одним из наиболее важных тактических паттернов, поскольку они определяют границы согласованности в пределах вашей области. Они гарантируют, что бизнес-инварианты сохраняются во всех связанных сущностях, при этом сложность остается управляемой.

```java
public class Order { // Aggregate Root
    private final OrderId id;
    private final CustomerId customerId;
    private final List<OrderItem> items; // Internal entities
    private OrderStatus status;
    
    // Только агрегатный корень может быть упомянут извне
    // Все изменения проходят через агрегатный корень
    
    public void changeItemQuantity(ProductId productId, int newQuantity) {
        OrderItem item = findItem(productId);
        if (item == null) {
            throw new IllegalArgumentException(«Item not found in order»);
        }
        
        if (status != OrderStatus.PENDING) {
            throw new IllegalStateException(«Невозможно изменить подтвержденный заказ»);
        }
        
        item.changeQuantity(newQuantity);
        recalculateTotal();
        
        // Бизнес-правило: заказы на сумму более 1000 долларов требуют утверждения
        if (totalAmount.isGreaterThan(new Money(new BigDecimal(«1000»)))) {
            this.status = OrderStatus.PENDING_APPROVAL;
        }
    }
}
```

Контроль доступа через агрегатный корень обеспечивает последовательное соблюдение бизнес-правил.

## Стратегия реализации

Переход от анемичных моделей к богатым доменным моделям требует системного подхода:

### Постепенный подход
1. **Начните с малого**: начните с хорошо понятных доменных концепций, особенно с классов с несколькими связанными методами обслуживания
2. **Определите бизнес-правила**: извлеките логику проверки, переходы состояний и вычисления из классов обслуживания
3. **Создайте типы домена**: замените примитивные типы объектами значений для концепций домена.
4. **Инкапсулируйте операции**: замените сеттеры методами, выражающими поведение (`order.confirm()` вместо `order.setStatus(CONFIRMED)`).
5. **Протестируйте логику домена**: используйте улучшенную тестируемость благодаря инкапсулированной бизнес-логике.

## Распространенные заблуждения

**Богатые доменные модели являются излишними для простых приложений CRUD**: хотя это верно для базовых операций, приложения обычно развиваются за пределы простого CRUD. Богатые модели способствуют этой эволюции.

**Несовместимость JPA/Hibernate**: современный JPA эффективно поддерживает богатые доменные модели. Конкретные техники, такие как `@Access(AccessType.FIELD)` и тщательный дизайн конструкторов, позволяют обеспечить интеграцию.

**Устранение сервисов**: сервисы приложений по-прежнему необходимы для координации рабочих процессов и управления транзакциями. Доменные сервисы обрабатывают сложную бизнес-логику. Разница заключается в уровне абстракции и распределении ответственности.

## Преимущества

Богатые доменные модели обеспечивают:

- **Самодокументирующийся код**: бизнес-правила, видимые в доменных объектах
- **Улучшенная инкапсуляция**: предотвращение недействительного представления состояния
- **Улучшенную тестируемость**: изолированное тестирование бизнес-логики
- **Снижение связи**: совместное размещение связанных данных и поведения
- **Ясное намерение**: имена методов, выражающие бизнес-операции, а не технические механизмы

## Резюме

Тактический DDD создает доменные модели, которые отражают сложность и богатство бизнес-домена. В то время как стратегический дизайн устанавливает границы и отношения, тактический дизайн предоставляет инструменты реализации для выразительных моделей в пределах этих границ.

Сущности, объекты значений, агрегаты и доменные службы позволяют создавать код, который эффективно выражает язык и концепции домена. Реализация требует времени и практики, но в результате дает более поддерживаемый и тестируемый код, согласованный с точкой зрения экспертов в данной области.

Цель состоит в том, чтобы правильно разместить бизнес-логику и создать модели, которые точно отражают домен, а не в том, чтобы устранить все службы или максимизировать интеллект объектов.