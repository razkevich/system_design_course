# Границы декомпозиции

> «Архитектура программного обеспечения — это набор структур, необходимых для анализа системы, который включает в себя программные элементы, отношения между ними и свойства обоих». — Лен Басс, Пол Клементс и Рик Казман

Архитектура программного обеспечения определяет компоненты и их взаимосвязи. Фундаментальный вопрос о том, как определить границы компонентов, лежит в основе каждого архитектурного решения.

**Декомпозиция программного обеспечения** — это процесс разбиения сложных систем на более мелкие, более управляемые компоненты. Он включает в себя определение границ, разделяющих одну функцию от другой, независимо от того, существуют ли эти границы в виде модулей в рамках одного процесса, сервисов в сети или команд в организации. Цель состоит в том, чтобы создать границы, которые способствуют пониманию, изменению и росту.

Декомпозиция применима ко всем системным архитектурам. Независимо от того, создаете ли вы монолитную, сервис-ориентированную архитектуру или микрофронтенд, принципы декомпозиции остаются центральными для создания поддерживаемых, масштабируемых и понятных систем. Правильная декомпозиция монолита часто требует большей дисциплины, чем в распределенных системах, где границы обеспечиваются сетевыми вызовами и отдельными развертываниями.

## Силы, формирующие границы

Принимая решения о декомпозиции, архитекторы реагируют на множество часто противоречивых сил. Понимание этих сил и их компромиссов необходимо для принятия обоснованных архитектурных решений.

### Функциональность домена: граница, определяемая бизнесом

Самая мощная сила, влияющая на создание границ, исходит от самой бизнес-сферы. Доменно-ориентированное проектирование (DDD) учит нас, что **пространство проблем** — реальная бизнес-сфера, которую мы пытаемся смоделировать — должно определять декомпозицию **пространства решений**. Тщательный анализ домена позволяет выявить **ограниченные контексты** — явные границы, в которых применяется конкретная модель домена, — и эти ограниченные контексты напрямую влияют на структуру компонентов нашего программного обеспечения.

Рассмотрим систему электронной коммерции. Анализ домена выявляет отдельные бизнес-возможности, которые естественным образом подсказывают границы сервисов:

- **Управление клиентами**: регистрация пользователей, профили, аутентификация и настройки
- **Каталог продуктов**: информация о продуктах, категории, поиск и рекомендации
- **Обработка заказов**: корзина покупок, оформление заказа, обработка платежей и выполнение заказов
- **Управление запасами**: уровень запасов, резервирование и координация цепочки поставок

Каждый из этих элементов представляет собой целостную бизнес-возможность, которая может принадлежать специальной команде и реализовываться в виде отдельного компонента или сервиса. Согласовывая архитектурные границы с этими естественными бизнес-границами, мы создаем системы, которые легче понять заинтересованным сторонам бизнеса и модифицировать и развивать командам разработчиков.

### Качественные характеристики: нефункциональные факторы

Качественные характеристики — производительность, безопасность, доступность, масштабируемость, удобство обслуживания и т. д. — оказывают значительное влияние на решения, касающиеся границ. Эти архитектурные качества часто вступают в конфликт с чистыми границами, определяемыми доменом, создавая напряженность, с которой архитекторам приходится тщательно справляться.

Рассмотрим платформу социальной сети, где логика домена предполагает разделение «профилей пользователей» и «действий пользователей» на разные ограниченные контексты. Однако требования к производительности могут заставить вас разместить данные профилей пользователей вместе с данными об их недавней активности в одном сервисе, чтобы избежать дорогостоящих соединений и сетевых вызовов для генерации новостной ленты. Аналогичным образом, финансовая система может потребовать разделить единую область «Торговля» на несколько сервисов для обеспечения безопасности — разделить ввод заказов, проверку рисков и исполнение сделок, даже если логически они относятся к одной области.

**Это противоречие является нормальным и зачастую необходимым.** Чистые границы доменов оптимизируют понимание бизнеса и организацию команды, в то время как границы, ориентированные на качество, оптимизируют поведение системы под нагрузкой, в условиях сбоев или ограничений безопасности. Важно сознательно делать такие компромиссы и документировать свои рассуждения. Иногда правильным архитектурным решением является жертвовать некоторой чистотой домена ради критически важных нефункциональных требований.

Неполный список атрибутов качества и их влияние на декомпозицию:

| Атрибут качества | Определение | Влияние на декомпозицию |
| ------------------- | -------------------------------------------------- | -------------------------------------------------------------------------------------------------------------- |
| **Производительность** | Время отклика, пропускная способность, использование ресурсов | Может способствовать использованию более крупных компонентов для избежания сетевых накладных расходов; предполагает совместное размещение часто взаимодействующих функций |
| **Масштабируемость** | Способность обрабатывать увеличенную нагрузку | Способствует более тонкой декомпозиции для независимого масштабирования компонентов |
| **Безопасность** | Защита от угроз и несанкционированного доступа | Создает дополнительные границы для контроля доступа; предполагает разделение обработки конфиденциальных данных |
| **Доступность** | Время безотказной работы системы и отказоустойчивость | Поощряет изоляцию критически важных и некритических функций; предполагает границы избыточности |
| **Удобосервисность** | Простота модификации и усовершенствования | Предпочтительны четкие, стабильные интерфейсы и разделение задач |
| **Развертываемость** | Простота выпуска изменений | Стремление к независимым единицам развертывания, согласованным с частотой изменений |

### Технические и организационные ограничения

Технические ограничения — среды развертывания, существующие системы, ограничения платформы, выбор технологий — создают практические границы, которые значительно влияют на решения о декомпозиции. Эти ограничения часто перекрывают идеальные границы домена или другие границы, вынуждая идти на прагматичные компромиссы.

Закон Конвея гласит, что «организации, которые проектируют системы, вынуждены создавать проекты, которые являются копиями коммуникационных структур этих организаций». Структура команды, модели коммуникации, распределение навыков и организационные границы неизбежно определяют эволюцию систем. Структура команды, в которой есть специалисты по фронт-енду и бэк-енду, может естественным образом привести к границам, основанным на API, в то время как полнофункциональные команды могут предпочесть декомпозицию на основе функций.

### Дополнительные факторы декомпозиции

На структуру компонентов программного обеспечения влияют и другие факторы:

**Частота изменений**: компоненты, которые изменяются с разной скоростью, следует разделять. Пользовательские интерфейсы обычно изменяются чаще, чем основная бизнес-логика, которая, в свою очередь, изменяется чаще, чем базовая инфраструктура.

**Ответственность команды**: каждый компонент должен иметь четкого владельца. Совместная ответственность часто приводит к дополнительным затратам на координацию и неясной ответственности, в то время как четкие границы позволяют команде работать автономно.

**Соответствие нормативным требованиям и регулированию**: Нормативные требования часто диктуют конкретные границы. Финансовые системы могут потребовать отделения торговой логики от отчетности, а системы здравоохранения должны изолировать обработку данных пациентов.

**Технологическое разнообразие**: Различные компоненты могут выиграть от использования разных технологий. Для обработки данных может использоваться Python, для функций реального времени — Go, а для пользовательских интерфейсов — React.

**Гравитация данных**: операции имеют тенденцию группироваться вокруг места хранения данных. Этот принцип предполагает, что компоненты с высокой частотой доступа к данным должны располагаться рядом. Гравитация данных также влияет на физическую декомпозицию — хранение связанных данных в одной базе данных, центре обработки данных или географическом регионе может существенно повлиять на производительность и соответствие нормативным требованиям.

## Руководящие принципы проектирования границ

### Высокая связность, низкая связность

Рассмотренные ранее факторы, влияющие на декомпозицию (границы домена, атрибуты качества, организационные ограничения), и принцип высокой связности и низкой связанности — это два взаимодополняющих подхода к решению одной и той же фундаментальной проблемы. Факторы определяют бизнес- и технические силы, которые указывают, где может быть полезно установить границы, а принципы связности и связанности помогают оценить эффективность установленных границ. Они описывают одни и те же базовые концепции с помощью различной терминологии — доменно-ориентированное проектирование естественным образом приводит к высокой связности внутри ограниченных контекстов и низкой связанности между ними.

Этот принцип, впервые сформулированный Ларри Константином в 1970-х годах, остается краеугольным камнем хорошей декомпозиции. Он применим на всех уровнях проектирования программного обеспечения — от отдельных функций и классов до модулей, сервисов и целых систем.

**Связность** — это степень взаимосвязанности и сфокусированности обязанностей одного компонента. Высокая связность означает, что элементы внутри компонента работают вместе для достижения общей цели. Типы связности, ранжированные от лучшего к худшему:

- **Функциональная связность**: элементы работают вместе для выполнения одной четко определенной задачи *(лучший вариант — создает сфокусированные, повторно используемые компоненты)*
- **Связность данных**: элементы работают с одними и теми же структурами данных *(хороший вариант — естественная группировка вокруг данных)*
- **Связность изменений**: Элементы, которые изменяются по одним и тем же причинам *(хорошая — соответствует развитию бизнеса)*
- **Временная когезия**: Элементы, к которым обращаются или которые изменяются одновременно *(слабая — может указывать на отсутствие абстракции)*

Высокая когезия важна, потому что она упрощает понимание, тестирование, обслуживание и повторное использование компонентов. Когда компонент имеет четкую, сфокусированную цель, разработчики могут рассуждать о нем изолированно.

**Связанность** — это степень взаимозависимости между компонентами. Низкая связанность означает, что компоненты могут работать независимо друг от друга, имея минимальное представление о внутреннем устройстве друг друга. Типы связанности, от лучшего к худшему:

- **Связанность данных**: компоненты обмениваются только простыми данными *(лучший вариант — минимальная зависимость)*
- **Связанность штампов**: компоненты обмениваются структурами данных *(приемлемый вариант — распространен в хорошо спроектированных API)*
- **Связь управления**: один компонент управляет потоком другого *(проблематично — создает жесткие зависимости)*
- **Связь содержимого**: один компонент напрямую обращается к внутренним данным другого *(худший вариант — нарушает инкапсуляцию)*

Низкая связь имеет решающее значение, поскольку она обеспечивает независимую разработку, тестирование, развертывание и масштабирование. Когда компоненты слабо связаны, изменения в одном компоненте с меньшей вероятностью потребуют изменений в других. Этот принцип напрямую поддерживает философию микросервисов: каждый сервис должен быть независимо развертываемым, масштабируемым и поддерживаемым. Цель состоит в создании архитектур «без общего доступа», в которых сервисы взаимодействуют только через четко определенные интерфейсы, что позволяет командам работать автономно.

**Кванты архитектуры и границы связей**

Квант архитектуры, как определено Нилом Фордом и Марком Ричардсом в книге «Software Architecture: The Hard Parts», представляет собой «независимо развертываемый артефакт с высокой функциональной связностью, высокой статической связью и синхронной динамической связью». Это понятие связывает наши факторы декомпозиции с принципами связей — границы квантов часто совпадают с границами доменов, ответственностью команд и независимостью развертывания, о которых мы говорили ранее.

С точки зрения связей, кванты помогают нам понять:
- **Статическая связь**: общие базы данных, фреймворки и операционные зависимости (допустимы в пределах квантов, проблематичны между ними)
- **Динамическая связь**: шаблоны коммуникации во время выполнения (синхронные в пределах квантов для обеспечения согласованности, асинхронные между квантами для обеспечения независимости)

Не вся связь является плохой. Хорошая связь соответствует вашим архитектурным целям:
- **Приемлемая связь**: между компонентами, которые меняются вместе, принадлежат к одной бизнес-возможности или требуют высокой согласованности
- **Проблемная связь**: между компонентами, принадлежащими разным командам, с разными требованиями к масштабированию или разной частотой изменений

### Правило зависимости

Зависимости должны указывать на стабильность. Политики более высокого уровня — основные бизнес-правила и сценарии использования, которые определяют, что делает ваша система — не должны зависеть от деталей более низкого уровня, таких как базы данных, фреймворки или внешние API. Этот принцип, лежащий в основе чистой архитектуры (Роберт Мартин), гарантирует, что бизнес-логика остается стабильной, в то время как детали реализации могут развиваться.
Это означает:
- Бизнес-сущности не должны зависеть от баз данных
- Сценарии использования не должны зависеть от фреймворков пользовательского интерфейса
- Основная логика домена не должна зависеть от внешних сервисов

Гексагональная архитектура поддерживает этот принцип, создавая четкие направления зависимостей, с бизнес-логикой в центре, окруженной адаптерами, которые обрабатывают внешние задачи.

![[hexagonal.png]]

### Скрытие информации и дизайн интерфейса

Хорошо спроектированные границы показывают только то, что действительно нужно потребителям, создавая стабильные интерфейсы, которые скрывают внутренние детали реализации. Этот принцип, введенный Дэвидом Парнасом в 1970-х годах, является основополагающим для управления сложностью в больших системах.

Скрытие информации важно, потому что:
- уменьшает влияние изменений за счет локализации деталей реализации
- упрощает ментальную модель, необходимую потребителям для понимания
- позволяет вести параллельную разработку за счет определения четких контрактов
- поддерживает тестирование за счет предоставления стабильных интерфейсов для моделирования

Хорошие интерфейсы минимальны, стабильны и ориентированы на потребности потребителя, а не на удобство реализации поставщика.

Этот принцип применяется на нескольких уровнях:
- **Уровень кода**: модули Java (Project Jigsaw) раскрывают только определенные пакеты, скрывая детали реализации
- **Уровень сервиса**: микросервисы раскрывают REST API, скрывая внутренние модели данных и бизнес-логику
- **Уровень системы**: публичные API скрывают сложность всей платформы (например, как платежный API Stripe скрывает сложность обработки платежей)
- **Уровень команды**: четко определенные интерфейсы команды указывают, какие услуги предоставляет и использует команда, скрывая внутренние процессы команды.

## Распространенные антипаттерны и решения

### Распределенный монолит
Услуги, которые разделены физически, но не логически, создают сложность распределенных систем без преимуществ истинной независимости. Эти системы часто требуют скоординированного развертывания на нескольких службах для реализации простых функций.

**Решения**:
- Сосредоточьтесь на бизнес-границах, а не на технических
- Убедитесь, что сервисы могут разрабатываться, тестироваться и развертываться независимо
- Минимизируйте межсервисные транзакции и синхронную коммуникацию
- Проектируйте сервисы с учетом бизнес-возможностей, а не данных

### Анемичный компонент
Компоненты — будь то сервисы, модули или классы — которые слишком малы, чтобы оправдать свое существование в качестве отдельных единиц. Они обычно содержат мало логики и в основном служат механизмами передачи данных.

**Решения**:
- Объедините связанные функции в единые бизнес-возможности
- Сосредоточьтесь на значимых бизнес-операциях, а не на операциях CRUD
- Убедитесь, что каждый компонент имеет достаточную логику, чтобы оправдать отдельное существование
- Применяйте тест «Может ли это быть функцией?»

### Божественный компонент
Компоненты, которые пытаются делать слишком много, нарушая принцип единственной ответственности и становясь узкими местами для нескольких команд и вариантов использования.

**Решения**:
- Разделите по бизнес-возможностям с помощью доменно-ориентированного проектирования
- Выделите общие задачи в отдельные, специализированные компоненты
- Определите и разделите различные причины изменений
- Найдите естественные границы в бизнес-домене

### Повсеместные сквозные задачи
Реализация инфраструктурных задач, таких как ведение журналов, безопасность или кэширование, в каждом бизнес-компоненте вместо выделения их в отдельные сквозные задачи.

**Пример**: Каждый сервис реализует собственную логику аутентификации вместо использования общего сервиса или фреймворка аутентификации.

**Решения**:
- Выделить инфраструктурные проблемы в общие библиотеки или сервисы
- Использовать аспектно-ориентированное программирование или паттерны промежуточного программного обеспечения
- Реализовать проблемы на уровне платформы (шлюзы API, сервисная сетка)

### Преждевременная декомпозиция
Разделение систем до понимания границ домена, что часто приводит к многословным интерфейсам и сложной координации.
**Решения**:
- Начните с модульного монолита, чтобы понять границы
- Используйте шаблоны, такие как Strangler Fig, для постепенного извлечения сервисов
- Сосредоточьтесь на изучении границ домена перед их реализацией
- Вначале отдавайте предпочтение большим, сплоченным компонентам, а не множеству маленьких

## Эволюция и наблюдаемость

Границы должны эволюционировать со временем по мере углубления понимания и изменения требований. Для поддержки этой эволюции требуется тщательно продуманный дизайн, обеспечивающий наблюдаемость и возможность изменений.

**Почему эволюция важна**: Первоначальные решения о декомпозиции редко бывают идеальными. Понимание области растет, структуры команд меняются, требования к производительности изменяются, появляются новые технологии. Системы, которые не могут развивать свои границы, становятся жесткими и в конечном итоге устаревают.

**Функции архитектурной пригодности**: это автоматизированные тесты, которые проверяют целостность границ с течением времени. Примеры:
- Анализ зависимостей для обнаружения нежелательной связности
- Тесты производительности для проверки эффективности границ
- Тесты контрактов для обеспечения стабильности интерфейса
- Метрики сложности для выявления растущих компонентов God

**Комплексный мониторинг**: чтобы понять, как границы работают на практике, необходимо иметь представление о следующем:
- **Метрики**: время отклика, частота ошибок, пропускная способность между границами компонентов
- **Журналы**: структурированное ведение журналов, которое отслеживает запросы через границы
- **Трассировка**: распределенная трассировка для понимания потоков запросов и узких мест
- **Сопоставление зависимостей**: понимание взаимодействия компонентов в реальном времени

**Шаблоны постепенной миграции**: безопасно изменяйте границы с помощью проверенных шаблонов:
- **Strangler Fig**: постепенная замена старых компонентов новыми
- **Параллельное выполнение**: параллельное выполнение старых и новых реализаций для проверки
- **Переключение функций**: управление изменениями границ с помощью настроек
- **Разветвление по абстракции**: скрытие изменений границ за стабильными интерфейсами

**Инструменты для эволюции**: современные инструменты, такие как Spring Modulith, позволяют создавать модульные монолиты с четкими внутренними границами, которые впоследствии можно извлечь в виде отдельных развертываемых единиц, когда преимущества оправдывают сложность.

## Практические рекомендации

**Систематический подход к проектированию границ:**

1. **Начните с бизнес-границ**, используя доменно-ориентированное проектирование
- Проведите сессии по моделированию домена с участием бизнес-экспертов
- Определите ограниченные контексты и их взаимосвязи
- Сопоставьте бизнес-возможности с потенциальными границами компонентов

2. **Уделите приоритетное внимание независимости развертывания** как ключевому ограничению проектирования
- Каждый компонент должен быть развертываемым без координации с другими
- Минимизируйте общие базы данных и синхронные зависимости
- Проектируйте с учетом плавного ухудшения работы при сбое зависимостей

3. **Проектируйте с учетом изменений**, отделяя стабильные политики от изменчивых реализаций
- Сохраняйте стабильность бизнес-правил и гибкость инфраструктуры
- Используйте инверсию зависимостей для защиты основной логики от внешних изменений
- Явно версионируйте интерфейсы и проектируйте с учетом обратной совместимости

4. **Измеряйте и контролируйте связность**, чтобы понять фактические и предполагаемые границы
- Отслеживайте модели межграничной коммуникации
- Контролируйте требования к координации развертывания
- Измеряйте производительность команды и скорость разработки

5. **Явно обозначайте компромиссы** с помощью записей о принятых архитектурных решениях
- Документируйте, почему границы были проведены именно в этих местах
- Записывайте рассмотренные альтернативы и сделанные компромиссы
- Планируйте пересмотр решений по мере изменения контекста

## Заключение

Проведение границ в архитектуре программного обеспечения требует как аналитических, так и творческих навыков. Наиболее успешные архитекторы понимают, что идеальных границ не существует — есть только границы, подходящие для текущего контекста, ограничений и целей.

Цель не в том, чтобы полностью устранить связность, а в том, чтобы существующая связность была преднамеренной, хорошо понятной и согласованной с архитектурными целями. Хорошие границы облегчают правильные вещи и затрудняют неправильные. Они позволяют командам работать независимо, обеспечивая при этом слаженную работу системы.
При решении задач декомпозиции границы должны облегчать будущие изменения, а не усложнять их. Начните с простого, учитесь на реальных примерах использования и развивайте границы по мере роста понимания. Наиболее долговечные архитектуры — это те, которые могут адаптировать свои границы к меняющимся потребностям, сохраняя при этом свою сущностную целостность.